# 7. 오류 처리

### 오류 코드보다 예외를 사용하라

오류 코드 이전에는 if 문으로 각 오류마다 로직을 걸었어야 했지만, 예외가 생긴 이후로 예외처리를 이용해 쉽게 해결이 가능하다.  

<br/>

### Try-Catch-Finally 문부터 작성하라

try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성  있게 유지해야 한다.  
그러므로 예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다.  

<br/>

### UnChecked Exception을 사용하라

안정적인 소프트웨어를 제작하는데에 Checked Exception은 필요하지 않다.  
결정적으로, OCP를 위반한다. 가장 하위 메서드에서 예외가 추가될 때  상위 메서드들은 모두 throw 절을 추가하게 될 것이다.  

<br/>

### 예외에 의미를 제공하라

오류 메세지에 실패한 연산 이름과 실패 유형을 언급해준다.  
애플리케이션이 로깅 기능을 사용한다면 catch 블록에서 오류를 기록하도록 충분한 정보를 넘겨준다.  

<br/>

### 호출자를 고려해 예외 클래스를 정의하라

한 클랫가 던지는 예외를 잡아 변환하는 wrapper 클래스를 정의하면 매우 유용하다.  
외부 API를 사용할 때 해당 방법을 사용하게 되면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다.  

wrapper 기법을 사용하면 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다. 프로그램이 사용하기 편리한 API를 정의하면 그만이다.  

<br/>

### 정상 흐름을 정의하라

```java
try{
    MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
    m_total += expenses.getTotal();
} catch(MealExpensesNotFound e) {
    m_total += getMealPerDiem();
}
```

식비를 비용으로 청구했다면 직원이 청구한 식비를 총계에 더하고, 식비를 비용으로 청구하지 않았다면 일일 기본 식비를 총계에 더한다.  
특수 상황을 처리할 필요가 없다면 더 간결한 코드가 될 것이다.  

```java
public class PerDiemMailExpenses implements MealExpensses {
    public int getTotal() {
        // 기본값으로 일일 기본 식비를 반환한다.
    }
}
```

ExpenseRepotDAO를 고쳐서 언제나 기본 식비를 바환하는 MealExpense 객체를 반환한다.  
이를 **특수 사례 패턴(SPECIAL CASE PATTERN)** 이라고 부른다. 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다.  

<br/>

### null을 반환하지 마라

null 을 반환하는 코드는 누구 하나라도 null 확인을 빼먹는다면 애플리케이션이 통제 불능에 빠질지도 모른다.  

<br/>

### null을 전달하지 마라

메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다.  
NPE를 막기위해서 이 null에 대한 분기를 만들어야 한다. 아니면 assert문을 사용하는 방법도 있다.  
하지만, 문서화가 잘 되어 코드 읽기는편하지만 문제를 해결하지는 못한다. 누군다 null을 전달하면 여전히 실행 오류가 발생한다.  

<br/>

### 결론

깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.  
오류 처리를 프로그램 논리오 ㅏ분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다.  
오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.