# 8. 경계

모든 소프트웨어를 직접 개발하는 경우는 드물고 패키지를 사고, 오픈 소스를 이용하기도 한다.  
이런 외부 코드를 기존의 코드에 깔끔하게 통합해야만 한다. 이 장에서는 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.  

### 외부 코드 사용하기

```java
Map sensors = new HashMap();
Sensor s = (Sensor)sensors.get(sensorId);
=>
Map<String, Sensor> sensors = new HashMap<Sensor>();
...
Sensor s = sensors.get(sensorId);
```

위와 같이 제네릭스를 사용하면 코드 가독성을 높일 수 있따.  
그러나 ``Map<String, Sensor>``가 사용자에게 필요하지 않은 기능까지 제공한다는 문제는 해결하지 못한다. 프로그램에서 ``Map<String, Sensor>`` 인스턴스를 여기저기로 넘긴다면, Map 인터페이스가 변할 경우, 수정할 코드가 상당히 많아진다. 밑의 코드는 Sensors 사용자가 제네릭스 사용 여부에 신경 쓸 필요 없도록 만든 것이다.  

```java
public class Sensors {
    private Map sensors = new HashMap();
    
    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
}
```

경계 인터페이스인 Map을 Sensors 안으로 숨긴다. 따라서 Map 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않는다. 제네릭스를 사용하든 하진 않든 더 이상 문제가 안 된다. Sensors 클래스 안에서 객체 유형을 관리하고 변환하기 때문이다.  

또한 Sensors 클래스는 프로그램에 필요한 인터페이스만 제공한다. 그래서 코드는 이해하기는 쉽지만 오용하기는 어렵다. Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.  

<br/>

### 경계 살피고 익히기

외부 패키지 테스트는 우리 책임이 아니지만 우리가 사용할 코드를 테스트하는 편이 바람직하다.  
우리쪽 코드를 작성해 외부의 라이브러리의 동작을 제대로 확인한다.  

<br/>

### 학습 데이터는 공짜 이상이다

학습 테스트를 돌려 패키지가 예상대로 도는지 검증하자.  

<br/>

### 아직 존재하지 않는 코드를 사용하기

한 팀에서 아직 API에 대한 설계를 하지 않아 정보가 불명할 때, 임시의 코드같은 것을 만들어서 테스트하고자 하는 것을 테스트할 수 있다.  

<br/>

### 깨끗한 경계

경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다. 이쪽 코드에서 외부 패키지를 세세하게 알아야 할 필요가 없다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.  

외부 패키지를 호출하는 코드를 가능한 줄여 경계를 곤리하자. Map에서 봤듯이, 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자. 어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다.

***