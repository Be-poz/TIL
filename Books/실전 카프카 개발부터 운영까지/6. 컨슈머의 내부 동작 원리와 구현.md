# 컨슈머의 내부 동작 원리와 구현

## 컨슈머 오프셋 관리

컨슈머의 동작 중 가장 핵심은 오프셋 관리다. 컨슈머는 카프카에 저장된 메세지를 꺼내오는 역할을 하기 때문에 컨슈머가 메세지를 어디까지 가져왔는지를 표시하는 것은 매우 중요하다.  

컨슈머 그룹은 자신의 오프셋 정보를 카프카에서 가장 안전한 저장소인 토픽에 저장한다. 즉 ``__consumer_offsets`` 토픽에 각 컨슈머 그룹별로 오프셋 위치 정보가 기록된다. 이때 컨슈머 그룹은 컨슈머 그룹, 토픽, 파티션 등의 내용을 통합해 기록한다. 이것을 이용하여 컨슈머 그룹내의 컨슈머의 변경이 발생하는 경우 어느 위치까지 읽었는지를 추적할 수 있따.  

* offsets.topic.num.partition: 기본값 50
* offsets.topic.replication.factor: 기본값 3

<br/>

## 그룹 코디네이터

컨슈머 그룹내의 컨슈머가 변경되어 각 컨슈머들에게 작업을 균등하게 분배하는 것을 **리밸런싱**이라고 부른다.  
이 그룹 관리를 위해 **그룹 코디네이터**라는 것이 존재한다.  

그룹 코디네이터는 카프카 클러스터 내의 브로커 중 하나에 위치한다.  

컨슈머 그룹 등록 과정에서 그룹 코디네이터와 컨슈머의 동작은 다음과 같다.  

1. 초기 커넥션을 위해 컨슈머는 ``bootstrap.brokers`` 정보와 함께 요청 보낸다.
2. 해당 요청을 받은 브로커는 그룹 코디네이터를 생성하고 컨슈머에게 응답을 보낸다. 컨슈머 그룹의 첫 번째 컨슈머가 등록될 때까지 아무 작업도 일어나지 않는다.
3. 그룹 코디네이터는 ``group.initial.rebalance.delay.ms``의 시간 동안 컨슈머의 요청을 기다린다.
4. 컨슈머는 컨슈머 등록 요청을 그룹 코디네이터에게 보낸다. 이때 가장 먼저 요청을 보내는 컨슈머가 컨슈머 그룹의 리더가 된다.
5. 컨슈머 등록 요청을 받은 그룹 코디네이터는 해당 컨슈머 그룹이 구독하는 토픽 파티션 리스트 등 리더 컨슈머의 요청에 응답을 보낸다.
6. 리더 컨슈머는 정해진 컨슈머 파티션 할당 전략에 따라 그룹 내 컨슈머들에게 파티션을 할당한 뒤 그룹 코디네이터에게 전달한다.
7. 그룹 코디네이터는 해당 정보를 캐시하고 각 그룹 내 컨슈머들에게 성공을 알린다.
8. 각 컨슈머들은 각자 지정된 토픽 파티션으로부터 메세지들을 가져온다.

컨슈머는 그룹에서 빠져나올 수도 들어갈 수도 있다. 이때 join 또는 leave 요청을 보낸다. 하지만 leave 요청을 보내지 못하고 종료되는 경우가 있는데 코디네이터는 서로 하트비트를 주고받으면서 이를 감지한다.  

* heartbeat.interval.ms
  * 기본 값 3,000
  * 그룹 코디네이터와 하트비트 인터벌 시간이며, session.timeout.ms의 1/3 수준이 적당하다.
* session.timeout.ms
  * 기본 값 10,000
  * 어떤 컨슈머가 특정 시간 안에 하트비트를 받지 못하면 문제가 발생했다고 판단해 컨슈머 그룹에서 해당 컨슈머는 제거되고 리밸런싱 동작이 일어난다.
* max.poll.interval.ms
  * 기본 값 300,000
  * 컨슈머는 주기적으로 poll()을 호출해 토픽에서 레코드들을 가져오는데, poll() 호출 후 최대 5분간 poll() 호출이 없다면 컨슈머가 문제가 있는 것으로 판단해 리밸런싱 동작이 일어난다.



리밸런싱 동작은 비용이 높으므로 리밸런싱이 자주 발생하지 않도록 주의해야 한다.  

컨슈머의 다운을 빠르게 감지하도록 설정해둔다면, 일시적인 컨슈머의 타임아웃이나 일시적인 TCP 패킷 손실로 인해 원하지 않은 리밸런싱이 빈번하게 일어나는 현상이 발생할 수 있다.  

반대로 그룹 코디네이터가 컨슈머 다운을 늦게 감지하도록 설정해두면, 그 시간만큼 해당 파티션의 메세지를 읽지 못하는 현상이 발생할 수도 있다. 가능하면 기본 설정을 유지하기를 권장한다고 한다.

<br/>

## 스태틱 멤버십

**스태틱 멤버십**이란 컨슈머 그룹 내에서 컨슈머가 재시작 등으로 그룹에서 나갔다가 다시 합류하더라도 리밸런싱이 일어나지 않게 한다. 즉 컨슈머가 인식할 수 있는 ID를 적용함으로써 다시 합류하더라도 그룹 코디네이터가 기존 구성원임을 인식할 수 있게 하는 것이다. 스태틱 멤버십 기능이 적용된 컨슈머는 그룹에서 떠날 때 그룹 코디네이터에게 알리지 않으므로 불필요한 리밸런싱도 발생하지 않는다.  

설정하는 방법은 ``group.instance.id``만 설정하면 적용되고, 카프카 버전이 2.3 이상이면 된다.  
그리고 이 옵션에는 그룹 코디네이터가 컨슈머를 식별하기 위해 컨슈머 인스턴스별로 고유한 값을 입력해야 한다.  
예를 들어 접두어로 'consumer-' 라고 지정하고, 접미어는 호스트네임이나 서버의 IP 등을 이용해 'consumer-hostname1', 'consumer-hostname2'와 같이 입력하는 방법도 있다.  

만약 이 기능을 적용한다면 ``session.timeout.ms``을 기본값보다 큰 값으로 조정해야 한다. 불필요한 리밸런싱 동작을 최소화하기 위함이 스태틱 멤버십의 목적인데 이 값이 작다면 불필요한 리밸런싱이 계속 일어나기 때문이다.  
따라서 컨슈머의 재시작 시간을 고려해서 적절한 시간값으로 조정해둬야 한다.  

### 일반 컨슈머 그룹과 스태틱 멤버십이 적용된 컨슈머 그룹의 동작차이

파티션 0 -> 컨슈머1  
파티션 1 -> 컨슈머2  
파티션 2 -> 컨슈머3  

이런 경우에서 컨슈머 3이 빠지게 되었을 때, 리밸런싱은 그룹에서 떠나는 컨슈머만 대상으로 동작하는 것이 아니라, 컨슈머 그룹 내 전체 컨슈머를 대상으로 동작한다. 컨슈머 리밸런싱 동작 과정 중 일시적으로 모든 컨슈머가 일시 중지하게 된다.  

그리고 브로커가 다시 복구되어 합류한다면 또다시 리밸런싱 동작이 일어나게 될 것이다.  

스태틱 멤버십이 적용되었다면 ``session.timeout.ms`` 에 설정한 값에 도달하기 전까지는 리밸런싱이 아예 일어나지 않는다.  
만약 이 값을 넘긴다면 동일하게 리밸런싱이 일어나게 될 것이다. 그러니깐 한 마디로 말하자면, 리밸런싱을 최소화하는 것이다.  

<br/>

## 컨슈머 파티션 할당 전략

프로듀서의 파티셔너는 레코드를 토픽의 어느 파티션으로 전송할지를 결정하는 역할을 했다.  
컨슈머의 동작에서도 이와 유사하게 대상 토픽의 어느 파티션으로부터 레코드를 읽어올지를 결정한다.  

전략으로는 ``RangeAssignor``, ``RoundRobinAssignor``, ``StickyAssignor``, ``CooperativeStickyAssignor`` 이렇게 4가지가 있다. 

### 레인지 파티션 할당 전략

파티션 할당 전략 중 기본값이다. 먼저 구독하는 토픽에 대한 파티션을 사전 순서대로 나열한 후 컨슈머를 순서대로 정렬한다. 그런 다음  각 컨슈머가 몇 개의 파티션을 할당해야 하는지 전체 파티션 수를 컨슈머 수로 나눈다. 균등하게 나눠지지 않는다면 앞쪽의 컨슈머들은 추가 파티션을 할당받게 된다. 파티션의 수보다 컨슈머의 수가 많으면 파티션을 할당받지 못하는 컨슈머가 발생할 수도 있다.

<img width="632" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/4c2689da-a4b7-41f1-917e-5cb386fb8006">

불균등하게 할당되는 전략인데 사용하는 이유는 레인지 파티션 할당 전략은 동일한 레코드 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할 때 유용할 수 있다.  

예를 들어 토픽A와 토픽B 모두 레코드 키가 abc인 값을 보낼 때에 결과적으로 하나의 컨슈머가 이 레코드 2개를 모두 가지게 되기 떄문이다. 불균등한 상태로 운영될 수 있으니 조심해야 한다.  

프로듀서의 파티션 할당 전략에서 레코드 키가 존재할 때에 키를 해싱하여 파티션에 분배하므로 2개의 토픽에 동일하게 파티션 n번에 들어가게 되고 컨슈머가 이것들을 다 컨슘할 수 있는 것이다.  

## 라운드 로빈 파티션 할당 전략

<img width="599" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/6e0ee3c8-b4c0-4243-aff5-407f6777b5eb">

라운드 로빈은 이름 그대로 라운드 로빈이다. 레인지 파티션 전략이 이제야 이해가 조금 더 간다. 라운드 로빈으로 하면 파티션 3번이 각각 서로 다른 컨슈머로 가는 것을 확인할 수 있다.  

### 스티키 파티션 할당 전략

리밸런싱이 일어나면 기존에 매핑됐던 파티션과 동일한 컨슈머가 다시 매핑되리라고는 보장할 수 없다. 재할당 작업이 발생하더라도 기존에 매핑했떤 파티션과 컨슈머를 최대한 유지하려고 하는 전략이 바로 스티키 파티션 할당 전략이다.  

스티키 파티션 할당 전략은 두 가지 목적으로 컨슈머에 파티션을 할당한다.  

1. 균형 잡힌 파티션 할당
2. 재할당이 발생할 때 되도록 기존의 할당된 파티션 정보를 보장

두 번째 보다는 첫 번째의 이유가 더 크기 때문에 이 전략을 사용한다고 하더라도 무조건 기존의 파티션과 컨슈머를 유지하지는 않는다.  

<img width="1365" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/b1db86d0-ea46-4818-ae39-083304f2e2fb">

스티키 파티션 할당 전략이 이상적으로 동작하는 이유는 아래의 규칙에 따라 수행하기 때문이다.  

* 컨슈머들의 최대 할당된 파티션의 수의 차이는 1
* 기존에 존재하는 파티션 할당은 최대한 유지함
* 재할당 동작 시 유효하지 않은 모든 파티션 할당은 제거함
* 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머들에 할당

최소한의 움직임으로 컨슈머를 할당할 수 있으므로 라운드 로빈 할당 전략보다 효율적이다.  

### 협력적 스티키 파티션 할당 전략

<img width="1279" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/6b18c421-74a8-4a3c-b653-e99968e63db3">

ㄹ 

