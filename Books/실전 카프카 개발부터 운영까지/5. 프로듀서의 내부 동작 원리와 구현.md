# 프로듀서의 내부 동작 원리와 구현

## 파티셔너

메세지를 토픽의 어떤 파티션에 보낼지 결정하는 것이 **파티셔너**다. 기본적으로 메세지의 키를 해시 처리해서 파티션을 구하는데 파티션이 확장되는 경우 확장 이전에 특정 키가 들어가는 파티션의 번호와 확장 이후의 파티션의 번호가 달라질 수 있기 때문에 해시 방식을 이용할 때에는 파티션 수를 변경하지 않는 것이 권장된다.  

### 라운드 로빈 전략

<img width="957" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/7a7ad1cc-8880-483e-b858-cc6d2aaa47f2">

키 값이 null 일 때 라운드 로빈 방식이 사용된다.  

파티셔너를 거친 후의 레코드들은 배치 처리를 위해 프로듀서의 버퍼 메모리 영역에서 잠시 대기한 후 카프카로 전송된다.  
이때 라운드 로빈 전략은 효율을 떨어뜨릴 수 있다.  

위의 그림과 같이 각 파티션 별로 배치 전송을 위해 필요한 레코드 수가 3이라고 하자, 이 때 레코드 7부터 각 파티션당 배치 전송을 위해 필요한 레코드 수를 충족하게 될 것이다. 그 이전까지는 계속 대기하게 된다.  

물론 옵션에다가 특정 시간 초과 시 레코드를 전송하도록 설정할 수 있지만 그림에서 파티션2와 같은 경우 압축의 효과를 얻지 못한 채 레코드 하나만 보내게 되므로 비효율 적이다.  

### 스티키 파티셔닝 전략

<img width="964" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/d2059714-14bf-41ea-a820-928e13fb0cbe">

카프카 2.4 버전 부터는 하나의 파티션에 레코드 수를 먼저 채워 카프카로 빠르게 배치 전송하는 **스티키 파티셔닝 전략**을 사용한다. 동작 방식이 아주 살짝 바뀌긴 했지만 굉장히 효율적이다. 컨플루언트에 따르면 30% 이상 지연시간이 감소하고 프로듀서의 CPU 사용률도 줄어들었다고 한다.  

책에서는 라운드 로빈의 비효율을 개선하기 위한 전략으로 나오는데, 스티키 파티셔닝 전략은 특정 메세지 키인 경우 특정 파티션에 붙게끔 하는 그런 전략의 의미로도 많이 사용되는 것 같다.  

https://www.confluent.io/ko-kr/blog/apache-kafka-producer-improvements-sticky-partitioner/

여기 글을 보면 key 값이 null 일 경우, 2.3 버전 이전에는 라운드 로빈 방식이 default 동작 방식이고 2.4 이후에는 스티키 파티셔닝 방식이 default 동작 방식이라고 나온다. key 값이 존재할 때에는 버전 관계없이 해싱 방식이 default인 것 같다.

<Br/>

## 프로듀서의 배치

