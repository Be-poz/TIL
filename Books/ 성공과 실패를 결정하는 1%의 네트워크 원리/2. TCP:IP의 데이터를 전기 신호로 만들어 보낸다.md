# TCP/IP의 데이터를 전기 신호로 만들어 보낸다

## 소켓을 작성한다

### 프로토콜 스택의 내부 구성

애플리케이션의 아랫부분에는 Socket 라이브러리가 있다. 이 안의 리졸버가 DNS 서버에 조회하는 동작을 실행한다. 그 아래에는 OS가 존재하는데 여기에 프로토콜 스택이 있다. 프로토콜 스택의 윗 부분에는 TCP와 UDP가 존재하며 이 둘이 애플리케이션에서 보낸 의뢰를 받아 송수신 동작을 실행한다. 그 아래에는 IP 프로토콜을 사용하여 패킷 송수신 동작을 제어하는 부분이 있다. 인터넷에서 데이터를 운반할 때 데이터를 작게 나누어 패킷이라는 형태로 운반하는데, 이 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할이다. IP 안에는 ICMP(패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메세지를 통지할 때 사용)와 ARP(IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용)이 있다. IP의 아래에는 LAN의 아래에는 LAN 드라이버가 있으며 LAN 어댑터의 하드웨어를 제어한다. LAN 어댑터는 실제 송수신 동작, 즉 케이블에 대해 신호를 송수신하는 동작을 실행한다.  

### 소켓의 실체는 통신 제어용 제어 정보

통신 상대의 IP 주소, 포트 번호, 통신 동작의 진행 상태와 같은 제어 정보가 소켓의 실체라고 생각해도 된다. 프로토콜 스택은 이 정보를 참조하면서 동작한다.  

### Socket을 호출했을 때의 동작

애플리케이션이 소켓을 만들 것을 의뢰하면 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만든다. 이때 프로토콜 스택은 소켓 한 개 분량의 메모리 영역을 확보한다. 소켓이 만들어지면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다. 디스크립터는 프로토콜 스택의 내부에 있는 다수의 소켓 중 어느 것을 가리키는지를 나타내는 번호표와 같은 정보다. 디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송수신 동작을 의뢰할 때 디스크립터를 통지한다. 소켓에는 누구와 누가 통신하고 있는지, 그리고 그것이 어떤 상태로 있는지 등의 정보가 전부 기록되어 있으므로 디스크립터가 어느 소켓인지를 나타내면 필요한 정보는 전부 프로토콜 스택쪽에서 알 수 있다.  

<br/>

## 서버에 접속한다

### 접속의 의미

소켓을 만들면 애플리케이션은 connect를 호출한다. 그러면 자기쪽의 소켓을 서버측 소켓에 접속하게 되는데, 이더넷이나 통신 회선 등의 케이블은 항상 접속된 상태에 있으므로 케이블을 연결하지 않거나 분리하지 않는다. 그러므로 데이터를 신호로 변환하여 송신하기만 하면 언제든지 통신이 가능하다.  

소켓을 만든 직후에는 아무것도 기록되어 있지 않기 때문에 기록을 해야한다. 서버의 IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작의 한 가지 역할이다. 이것은 서버측도 마찬가지이기 때문에 클라이언트에서 본인의 IP 주소와 포트 번호를 서버측에 전달해주게 된다. 이 또한 접속 동작의 한 가지 역할이다.  

접속 동작의 첫 번째 동작은 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 것이다.  
데이터 송수신 동작을 실행할 때는 송수신하는 데이터를 일시적으로 저장하는 메모리 영역이 필요한데, 이 영역을 '버퍼 메모리' 라고 부른다. 버퍼 메모리의 확보도 접속 동작을 할 때 실행되는데, 이것이 '접속'한다는 동작의 의미이다.  

### 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

제어 정보는 크게 두 종류로 나눌 수가 있다. 하나는 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보다. 이것은 통신 동작 전체에서 어떤 정보가 필요한지 검토하여 내용을 TCP 프로토콜의 사양으로 규정하고 있다.  

이 항목은 고정화되어 있기 때문에 접속, 송수신, 연결 끊기의 각 단계에서 클라이언트와 서버가 대화할 때마다 거기에 이 제어 정보를 부가한다. 이 제어 정보를 패킷의 맨 앞부분에 배치하는 곳부터 헤더라고 부른다. 제어 정보는 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등을 프로토콜 스택의 동작을 제어하기 위해 소켓에 기록한다.  

### 접속 동작의 실제

소켓 라이브러리의 connect 메서드에 서버측의 IP 주소와 포트 번호를 쓰면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다. 그러면 TCP 담당 부분은 IP 주소로 표시된 상대와 제어 정보를 주고받는다. 이때 먼저 데이터 송수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만들게된다. 이렇게 해서 TCP 헤더를 만들면 이것을 IP 담당 부분에 건네주어 송신하도록 의뢰한다. 그러면 IP 담당 부분이 패킷 송신 동작을 실행하고 패킷이 서버에 도착하면 서버측의 IP 담당이 TCP 담당 부분에 건네주고, 이곳에서 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아낸다. 해당하는 소켓이 발견되면 여기에 필요한 정보를 기록하고 접속 동작이 진행중이라는 상태가 된다. 이 과정이 끝나면 서버의 TCP 담당 부분은 응답을 돌려보낸다. 이 과정에서 SYN, ACK와 같은 컨트롤 비트를 이용한다.  

돌아온 응답을 확인해서 SYN이 1이면 접속 성공이므로 소켓에 서버의 IP 주소나 포트 번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록한다. 그리고 ACK 비트로 응답을 하게된다. 이러한 파이프와 같은 연결을 커넥션이라고 한다. close를 호출하여 연결을 끊기도 한다.  

<br/>

## 데이터를 송수신한다

### 프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다

connect 이후 write 호출 시에 애플리케이션에서 프로토콜 스택에 데이터를 넘겨주게 되는데, 프로토콜 스택은 받은 데이터의 내용에 무엇이 쓰여있는지 알지 못하고 해당 길이만큼 바이너리 데이터가 1바이트씩 차례로 나열되어 있다고 인식할 뿐이다. 곧장 데이터를 송신하는 것이 아니라 일단 자체의 내부에 있는 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주기를 기다린다.  

 그 이유는 데이터를 곧장 보내게 된다면 1바이트씩 송신 의뢰하는 경우를 가정했을 때, 네트워크의 이용 효율이 저하되므로 어느 정도 뎅티러르 저장하고 나서 송수신 동작을 하게되는 것이다. 판단 요소는 하나의 한 패킷에 저장할 수 있는 데이터의 크기다. 프로토콜 스택은 MTU(Maximum Transmission Unit) 를 바탕으로 판단한다. 이것은 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이로, 이더넷에서는 보통 1500 바이트이다. IT 헤더, TCP 헤더 그리고 데이터를 포함한 것을 말하며, 헤더를 제외한 데이터의 길이만을 의미하는 것은 MSS(Maximum Segment Size) 이다. 애플리케이션에서 받은 데이터가 MSS를 초과하거나 MSS에 가까운 길이에 이르기까지 데이터를 저장하고 송신 동작을 하면 패킷이 잘게 나누어질 걱정을 할 필요가 없다.  

 또 다른 요소는 타이밍이다. MSS에 가깝게 데이터를 저장하려고 하는데 애플리케이션의 송신 속도가 느려지는 경우 송신 동작이 지연되므로 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행해야 한다. 따라서 프로토콜 스택은 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신하게된다.  

 애플리케이션 측에서 송신의 타이밍을 제어할 수도 있다. '버퍼에 머물지 않고 바로 송신할 것' 이라고 옵션을 지정하면 바로바로 송신 동작을 실행하게 된다. 브라우저와 같이 대화형 애플리케이션이 서버에 메세지를 보낼 때는 버퍼에 머무는 부분만큼 응답 시간이 지연되므로 이 옵션을 사용하는 경우가 많을 것이다.  

### 데이터가 클 때는 분할하여 보낸다

블로그 글 같은 경우 데이터가 길기 때문에 이미 MSS의 길이를 초과했기 때문에 다음 데이터를 기다릴 필요가 없다. 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신한다.  

### ACK 번호를 사용하여 패킷이 도착했는지 확인한다

TCP는 헤더에 시퀀스 번호라는 항목을 기록하고 이를 이용하여 수신측에서 어떤 데이터가 누락되었는지를 확인하고 해당 번호를 ACK 번호에 기록하여 송신측에 알려준다. 이를 수신 확인 응답 이라고 부른다. 송신측은 이것을 통해 상대가 어디까지 수신했는지를 파악한다. 예를 들면 1,460 번째 바이트까지 수신 완료한 상태에서 시퀀스 번호가 1461인 패킷이 도착하지 않고 2921인 패킷이 도착하면 누락된 것을 알 수가 있다. 이 초기값은 1이 아닌 난수로 정하며 데이터의 송수신을 시작하기 전에 초기값을 상대에게 알리게 되어 있다. 접속 동작 부분에서 SYN이라는 제어 비트를 1로 하여 서버에 보내게 되는데 이 과정에서 시퀀스 번호에도 값을 설정하게 되어 있어 시퀀스 번호의 값이 초기값을 나타낸다. 이 과정은 서버 측의 입장에서도 마찬가지로 시퀀스 번호를 이용하여 클라이언트한테 응답한다.  

### 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다

ACK 번호가 돌아오는 것을 기다리는 시간을 타임아웃 값이라고 한다. 네트워크 정체가 일어나면 대기 시간을 어느 정도 길게 설정해야 한다. 그렇지 않으면 ACK 번호가 돌아오기 전에 다시 보내야 하는 사태가 일어난다. 오히려 네트워크 혼잡을 악화시킬 수가 있다. 그래서 데이터 송신 동작을 실행하고 있을 때 항상 ACK 번호가 돌아오는 시간을 계산해 두고 이 시간이 지연되면 이에 대응하여 대기 시간도 늘린다. 반대로 곧바로 ACK 번호가 돌아온다면 대기 시간을 짧게 설정한다.  

### 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다

패킷을 하나 보내고 하나 응답받고 하는 식은 굉장히 비효율 적이다. 따라서 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 윈도우 제어라는 방법을 사용한다. 그러나 마구잡이로 보내게 된다면 수신측의 능력을 초과하여 패킷을 보내는 사태가 일어날 수도 있다. 이를 막기 위해 수신측은 수신 수신 버퍼에 데이터를 임시 보관하고 수신 처리를 진행한다. 수신 처리가 끝나고 수신 버퍼에 빈 부분이 생기면 그 분량만큼 수신할 수 있는 데이터 양을 늘리므로 TCP 헤더의 윈도우 필드에서 이것을 송신측에 알린다. 송신측은 이 값을 가감하여 송신을 할지말지 정하게 된다. 0이면 중지할 것이다.  

수신 가능한 테이터 양의 최대값을 윈도우 사이즈 라고 부른다.  

### ACK 번호와 윈도우를 합승한다

윈도우 통지는 항상 일어날 필요가 없고 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때에만 필요하다. 그 이외에는 송신측에서 스스로 산출할 수 있기 때문이다. ACK 번호는 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보낸다. 즉 데이터를 수신한 후 즉시 보낸다고 생각하면 된다. 이 개념대로라면 ACK 번호 통지와 윈도우 통지의 패킷이 따로따로 송신측에 보내지게 된다.  

수신측은 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다려서 다음 통지 동작이 일어나면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 보낸다. 복수의 ACK 번호 통지가 연속해서 일어난 경우에도 패킷의 수를 줄일 수 있다. ACK q번호는 데이터를 어디까지 받았는지, 즉 수신한 데이터의 끝이 어디인지를 송신측에 알리는 것이므로 ACK 번호 통지가 연속하여 일어나면 최후의 것만 통지하고 도중의 것은 생략해도 상관없다. 윈도우 통지 또한 동일하다.  

<br/>

## 서버에서 연결을 끊어 소켓을 말소한다

### 데이터 보내기를 완료했을 때 연결을 끊는다

데이터 보내기를 완료한 쪽에서 연결 끊기 단계에 들어간다. 서버측에서 끊는 것으로 가정하겠다. 이 경우 서버측의 애플리케이션이 먼저 소켓 라이브러리의 close를 호출한다. 그러면 서버측의 프로토콜 스택이 TCP 헤더를 만들고 컨트롤 비트의 FIN 비트에 1을 설정하고 IP 담당 부분에 의뢰하여 클라이언트에 송신해 달라고 한다. 클라이언트 측은 해당 패킷을 받았다고 ACK 번호를 서버에 반송한다. 그리고 애플리케이션이 read를 호출했을 때에 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 클라이언트츠그이 애플리케이션에게 알린다. 이제 클라이언트 측에서도 close를 호출하고 데이터 송수신을 끝낸다. 그리고 서버한테 FIN을 날리고 서버에서도 응답으로 ACK를 반환한다.  

### 소켓을 말소한다

서버와의 연결을 끊고 소켓을 바로 말소하지 않고 잠시 기다린다. 서버가 FIN 을 보내고 나서 ACK를 못받은 경우에 다시 FIN을 보낼 수가 있는데 이 경우에 소켓이 말소되어있고 해당 포트를 다른 포트에서 사용하고 있다면 새 소켓에 FIN이 도착할 수도 있는 것이다. 따라서 일반적으로 보통 몇 분 정도 기다리고 나서 소켓을 말소한다.  

### <br/>

## IP와 이더넷의 패킷 송수신 동작

### 패킷의 기본

패킷은 '헤더' 와 '데이터'의 두 부분으로 구성된다. 패킷의 송신처가 되는 기기가 패킷을 만드는데, 헤더에는 적절한 제어 정보를 기록하고, 데이터 부분에는 얼마간의 데이터를 넣은 후 패킷을 가장 가까운 중계 장치에 송신한다. 중계 장치는 패킷의 헤더를 조사하여 패킷의 목적지를 판단한다. 이렇게 중계 장치를 거쳐서 수신처에 도착하게 되는데 이에 대한 회답 패킷을 보내게 되므로 송신처였던 기기가 수신처가 되고 수신처였던 기기가 송신처 기기가 된다. 따라서 명확하게 송신처인지 수신처인지 구별하지 않는 쪽이 편하다. 이러한 경우 송신처와 수신처의 기기를 묶어서 '엔드노드' 라고 부른다.  

이 방식에서 '라우터'와 '허브'라는 두 종류의 패킷 중계 장치를 이용하게 되는데 MAC용 헤더와 IP 헤더를 이용하게 된다. 액세스 대상 서버의 IP 주소를 IP 헤더의 수신처에 기록한다. MAC용 헤더에는 가장 먼저 가게될 라우터의 주소를 적어놓는다. 해당 라우터에 도착하면 그 다음 라우터의 주소를 다시 적어 놓는다. 이 방식을 반복해서 패킷을 전달하는 동작이 완료된다.  

### 패킷 송수신 동작의 개요

패킷 송신을 의뢰하게되면 TCP 담당 부분은 데이터의 조각에 TCP 헤더를 부가한 것을 IP 담당 부분에게 건네준다. 이것이 패킷에 들어가는 내용물이 되고, 이와 동시에 통신 상대의 IP 주소를 나타낸다. 만든 패킷을 네트워크용 하드웨어에 건네준다. 하드웨어는 이더넷이나 무선 LAN 등을 말한다. 이 때 이진 디지털 데이터를 받은 하드웨어에서는 전기나 빛의 신호 상태로 바뀌어 케이블에 송출한다.  

상대에게 패킷이 도착하면 거기에서 회답이 돌아온다. 이 패킷도 중계 장치가 운반하여 여기까지 운반해 오면서 패킷을 수신하는 장면이 된다. 순서는 송신의 순서의 반대와 같다.  

### 수신처 IP 주소를 기록한 IP 헤더를 만든다

IP 담당 부분은 TCP 담당 부분에서 패킷 송수신 의뢰를 받으면 IP 헤더를 만들어 TCP의 헤더의 앞에 붙인다. 헤더에 여러 정보들이 있지만 가장 중요한 것은 어디로 전달해야 하는지를 나타내는 수신처 IP 주소이다. 잘못된 주소라고 하더라도 그 주소를 그대로 헤더에 설정한다. 애플리케이션이 주는대로 따른다.  

송신처 IP 주소도 설정한다. 단순히 이 컴퓨터에 할당된 주소가 아니다. 한 기기에서 여러 개의 LAN 어댑터를 사용하고 있을 수 있기 때문이다. 상대의 라우터가 결정되면 LAN 어댑터에서 패킷을 송신해야 하는지 결정되며, LAN 어댑터가 결정되면 IP 주소가 결정된다. 패킷을 건네줄 상대를 판단하기 위해서 IP 용 표라고 불리는 경료표를 이용한다.  

### 이더넷용 MAC 헤더를 만든다

이더넷에는 TCP/IP 개념이 통용되지 않고, 다른 구조로 패킷의 수신처를 판단한다. 이떄 사용하는 것이 MAC 헤더다. 처음에는 어떤 주소로 설정해야할지 모르기 때문에 경로표에서 찾은 일치하는 행의 'Gateway' 항목에 기록되어 있는 IP 주소의 기기가 패킷을 건네줄 상대가 된다.  

### ARP로 수신처 라우터의 MAC 주소를 조사한다

이더넷에는 연결되어 있는 전원에게 패킷을 전달하는 브로드캐스트라는 구조가 있다. 이 구조를 이용하여 해당 IP 주소를 가지고 있는 기기를 찾고 그에 대해 가지고 있는 기기의 MAC 주소가 응답으로 돌아온다. 이 주소를 헤더에 설정하게 되는데 패킷을 보낼 때 마다 이 동작을 하면 ARP의 패킷이 불어나기 때문에 한 번 조사한 결과는 ARP 캐시라는 메모리 영역에 보존하여 다시 이용한다. 이 캐시에 저장되어 있지 않은 경우에만 ARP를 조회한다.  

 IP 주소가 변경된 경우 등 실제와 캐싱된 정보가 다를 수 있기 때문에 ARP 캐시에 저장된 값은 시간이 되면 삭제하게 되어 있다. 하지만 주소가 변경한 직후에는 ARP 캐시에 이전 값이 남아있기 때문에 제대로 통신할 수 없게 될 수 있다.  

### 이더넷의 기본

이더넷은 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술이다. 요즘에는 스위칭 허브를 이용하여 신호를 원하는 상대에게만 흐르게 한다.  

<br/>

## UDP 프로토콜을 이용한 송수신 동작

### 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다

TCP는 도착한 패킷은 다시 보내지 않고 오류로 도착하지 않은 패킷만 다시 보내는 구조가 필요하다. 어떤 상황에서는 TCP처럼 복잡한 구조를 사용해도 효율적으로 데이터를 다시 보낼 수 있다. 이것은 데이터가 한 개인 패킷에 수용할 수 있을 만큼 길이가 짧은 경우다. 패킷이 한 개밖에 없다면 이것이 없어졌는지 생각할 필요가 없지만, 데이터를 전부 다시 보낸다 해도 패킷을 한 개만 보내므로 낭비가 아니다. 접속하거나 연결을 끊을 때 제어용 패킷을 보낼 필요도 없다. 수신 확인 응답 패킷도 필요 없다.  

### 제어용 짧은 데이터

DNS 서버에 대한 조회 등 제어용으로 실행하는 정보 교환은 한 개의 패킷으로 끝나는 경우가 많아서 UDP를 사용한다. 일단 패킷을 보낸 후 TCP 처럼 보낸 패킷의 상태를 감시하지 않으므로 오류가 발생해도 프로토콜 스택은 신경쓰지 않지만 문제가 없다. 오류가 발생하면 회답이 돌아오지않으므로 애플리케이션이 그 사실을 알아차리고 데이터를 한 번 더 다시 보내면 그만이기 때문이다.  

### 음성 및 동영상 데이터

음성이나 영상 데이터는 결정된 시간 안에 데이터를 건네주어야 한다. TCP와 같이 수신 확인 응답에 의해 오류를 검출하여 다시 보내는 방법이라면 아무래도 다시 보낼 때 시간이 걸리므로 다시 보내도 재생 타이밍이 맞지 않을 수 있다. 음성이나 영상에는 데이터가 다소 없어도 치명적인 문제가 되지 않는 성질이 있다. 이와 같이 다시 보낼 필요가 없거나 다시 보내도 쓸모가 없으면 단순히 UDP로 데이터를 보내는 쪽이 더 효율적이다.  

***