# 웹 브라우저가 메시지를 만든다

## HTTP 리퀘스트 메시지를 작성한다

### 탐험 여행은 URL 입력부터 시작한다

http: , ftp: , file: , malito: 등 URL의 맨 앞에 있는 문자열은 액세스 하는 방법을 나타낸다. 웹 서버라면 HTTP, FTP 서버라면 FTP 프로토콜을 사용하는 식이다.

### 브라우저는 먼저 URL을 해독한다

URL은 ``http:`` + ``//`` + ``웹 서버명`` + ``/`` + ``디렉토리명`` + ``/``+ ... + ``파일명`` 의 요소를 가진다.  
앞에서 부터 설명하자면, 데이터 엑세스 방법, //는 나중에 이어지는 문자열이 서버의 이름임을 나타내고, 웹 서버명, 그 이후부터는 데이터 출처(파일)의 경로명을 나타낸다.  

``http://www.bepoz.com/dir1/file1.html`` 면 ``www.bepoz.com``이라는 웹 서버명의 ``/dir1/file1.html``의 파일에 엑세스한다는 의미이다. 만약 ``http://www.bepoz.com/dir1/``이라면 파일명을 쓰지 않고 생략한다는 뜻이다. 이 경우 어떤 파일을 액세스해야 할지 모르기 때문에 미리 서버측에 파일명을 설정해 둔다. 보통 ``default.html``이나 ``index.html``을 설정해둔다. ``http://www.bepoz.com``처럼 웹 서버의 도메인명만 쓴 경우도 마찬가지다. ``http://www.bepoz.com/file``이 경우는 파일명일 수도 디렉토리 명일 수도 있다. 이럴 떄에는 웹 서버에 ``file``이라는 파일이 있으면 파일명으로 보고, 디렉토리가 있으면 디렉토리명으로 본다.  

### HTTP의 기본 개념

HTTP 프로토콜은 클라이언트와 서버가 주고받는 메세지의 내용이나 순서를 정한 것이다. '무엇을', '어떻게 하는지' 를 판단한다. '무엇을' 은 URI를 보고, '어떻게 하는지' 는 메소드를 확인한다. (eg. GET, POST, PUT, DELETE, etc...)  

위는 리퀘스트 메시지고, 응답 메시지로는 Status를 포함한 메시지를 받게 된다.  

### HTTP 리퀘스트 메시지와 응답 메시지

첫 번째 행을 리퀘스트 라인이라고 한다. ``<메소드><공백><URI><공백><HTTP 버전>`` 의 형식을 띈다.  
그 다음 줄에는 메시지 헤더가 오게된다. 한 행에 한 개의 헤더 필드를 쓴다. 이 행을 통해 리퀘스트의 부가적인 정보를 나타낸다. 행 수는 상황에 따라 달라지며, 공백 행까지가 메시지 헤더가 된다. 공백 행 이후 메시지 본문이 나오게 되는데 서버에 송신하는 데이터가 들어가게 된다.  

응답 메시지는 스테이터스 라인이 먼저 나온다. ``<HTTP 버전><공백><스테이터스 코드><공백><응답 문구>``의 형식이다.  
이후 마찬가지로 메시지 헤더와 메시지 본문이 나온다. 메시지 본문에는 서버에서 클라이언트에 송신하는 데이터, 파일에서 읽은 데이터나 CGI 애플리케이션이 출력한 데이터가 들어가고, 바이너리 데이터로 취급된다.  

만약 ``/sample1.html`` 리퀘스트 메시지를 보내고 이에 대한 응답 메시지를 받았다고 하자. 해당 본문에 ``/bepoz.jpg``가 있으면 이를 위해 다시 리퀘스트 메시지를 보내고 응답을 받게 된다. 즉, 만약 한 문장에 n개의 영상이 포함되어 있다면 문장 파일을 읽는 리퀘스트와 영상 파일을 읽는 리퀘스트로, 총 n+1회 리퀘스트 메시지를 웹 서버에 보내게 된다.  

<br/>

## 웹 서버의 IP주소를 DNS서버에 조회한다

### IP 주소의 기본

HTTP의 메시지를 만들면 다음에는 OS에 의뢰해서 엑세스 대상 웹 서버에게 송신한다. 브라우저는 URL을 해독하거나 HTTP 메시지를 만들지만, 네트워크 송출 기능은 없기 때문에 OS에게 의뢰해서 송신하는 것이다. OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소로 상대를 지정해야 하기 때문에 IP 주소가 필요하다.  

서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어진다. 서브넷이란, 허브에 몇 대의 PC가 접속된 것이라고 생각하면 된다. 이것을 한 개의 단위로 생각하여 '서브넷' 이라고 부른다. 서브넷에 해당하는 주소를 네트워크 번호, 각 호스트한테는 호스트 번호라 하고, 이 두 주소를 합쳐서 IP주소라고 한다.  

### 도메인명과 IP 주소를 구분하여 사용하는 이유

IP 주소는 32비트, 즉 4바이트에 해당하는 개수 밖에 없지만, 도메인명은 최대 255바이트나 있기 때문에 그만큼 라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸리면서 네트워크의 속도가 느려진다. 고성능 라우터를 사용한다고 하더라도 라우터의 속도에는 한계가 있고, 한계에 다다르면 방대한 양의 데이터가 인터넷의 내부에 정체되어 있을 수 있다.  

이름을 알면 IP 주소를 알 수 있고, IP 주소를 알면 이름을 알 수 있는 원리를 사용하여 양쪽의 차이를 해소하는 방식을 택하고 있다. 그 원리가 DNS 이다.  

### Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다

IP 주소를 조사하는 방법은 가장 가까운 DNS 서버에 묻는 것이다. DNS 서버에 대해 클라이언트로 동작한다고 말할 수 있다. 이 클라이언트에 해당하는 것을 DNS 리졸버 또는 단순히 리졸버라고 부른다. DNS의 원리를 사용하여 IP 주소를 조사하는 것을 네임 리졸루션이라고 한다. 이 리졸루션을 실행하는 것이 리졸버이다.  

리졸버는 Socket 라이브러리에 들어있는 프로그램이다. OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위해 Socket 라이브러리가 있는 것이다.  

### 리졸버를 이용하여 DNS 서버를 조회한다

리졸버의 프로그램명(gethostbyname)과 웹 서버의 이름을 써서 리졸버를 호출할 수 있다. 리졸버를 호출하면 리졸버가 DNS 서버에 조회 메시지를 보내고, DNS 서버에서 응답 메시지가 돌아온다. 이 응답 메시지 속에 IP 주소가 포함되어 있으므로 이것을 추출하여 브라우저에서 지정한 메모리 영역에 써넣는다. 브라우저가 웹 서버에 메시지를 보낼 때 이 메모리 영역에서 IP 주소를 추출하여 OS에게 건네줌으로써 송신을 의뢰하게 된다.  

### 리졸버 내부의 작동

DNS 서버에게 메시지를 송신하는 것은 리졸버가 스스로 실행하는 것이 아니라 OS 내부에 포함된 **프로토콜 스택**을 호출하여 실행을 의뢰한다. 리졸버도 브라우저와 같이 네트워크에 대한 데이터를 송수신하는 기능이 없기 때문이다. (프로토콜 스택이란 OS에 내장된 네트워크 제어용 소프트웨어다. '프로토콜 드라이버', 'TCP/IP 소프트웨어' 등으로도 불린다)  

리졸버가 프로토콜 스택을 호출하면 제어가 리졸버에게 넘어가고 여기에서 메시지를 보내는 동작을 실행하여 LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신된다. 리졸버의 동작이 끝나고 제어가 애플리케이션(브라우저)에게 돌아온다. 이와 같이 컴퓨터의 내부는 다층 구조로 되어 있고 상위 계층에서 무엇인가 일을 의뢰했을 때 그 일을 스스로 전부 실행하지 않고 하위 계층에 실행을 의뢰하면서 처리를 진행한다.  

DNS 서버에 메시지를 송신할 때도 DNS 서버의 IP 주소가 필요하다. 이것은 TCP/IP 설정 항목의 하나하나로 컴퓨터에 미리 설정되어 있다. 리졸버는 여기에서 설정한 DNS 서버의 IP 주소에 조회 메시지를 보내게 된다.  

<br/>

## 전 세계의 DNS 서버가 연대한다

### DNS 서버의 기본 동작

DNS 서버의 기본 동작은 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답한다. 조회 메시지에는 이름, 클래스, 타입 이렇게 세 가지 정보가 포함되어 있다.  

* 이름 : 서버나 메일 배송 목적지(메일 주소에서 @ 뒷부분의 이름)와 같은 이름
* 클래스 : 인터넷과 네트워크를 구분하기 위해 만들었으나 현재 인터넷 이외의 네트워크는 소멸되었으므로 클래스는 항상 인터넷을 나타내는 'IN' 값이다.
* 타입 : 어떤 타입의 정보가 지원되는지를 나타낸다. (eg. A이면 이름에 IP 주소가 지원되는 것, MX이면 이름에 메일 배송 목적지가 지원되는 것)  
           이 타입에 따라 클라이언트에 회답하는 정보의 내용이 달라진다.

예를 들어, ``이름: www.lab.cyber.co.kr, 클래스:IN, 타입:A``이라고 보내면 DNS 서버는 등록된 정보를 찾아서 일치하는 것을 찾는다.  
위의 예시 조회 항목을 찾았을 때, 클라이언트에 회답하는 항목이 ``192.0.2.226``이라면 이 값을 클라이언트에 회답하게된다.  

위의 경우에는 IP 주소를 조회하기 위해 타입 A를 사용했다. 메일 배송 목적지를 조회할 때에는 MX라는 타입을 사용한다. 예를 들어, ``tone@cyber.co.kr``이라는 메일 주소가 있으면 @ 뒤의 이름이 메일 배송 목적지가 되기 때문에 이 이름을 조회한다. ``이름: cyber.co.kr, 클래스: IN, 타입: MX`` 해당 예시의 이름에 회답하는 항목은 ``10 mail.cyber.co.kr`` 와 같다. 앞의 10은 무엇일까? 타입이 MX인 경우에는 메일 서버의 우선 순위와 메일 서버의 이름이라는 두 항목이 등록되어 있다. 메일 서버 우선 순위란, 메일 배송 목적지로 복수의 메일 서버가 등록되어 있을 때 어느 메일 서버를 우선 선택해야 하는지를 판단하기 위한 값이다. 그리고, ``mail.cyber.co.kr``에 대한 IP 주소를 찾아서 우선순위와 IP 주소를 회답하게된다.  

타입에는 A, MX만 있는 것이 아니라 PTR, CNAME, NS, SOA 등이 있다. 등록 정보는 설정 파일 등에 입력되어 있으며, 1행 정보에 해당하는 것을 **리소스 레코드**라고 부른다.  

### 도메인의 계층

DNS 서버는 1대가 아니고 여러 대가 분산되어있다. 이 구조는 도메인명과 연관이 있다. ``www.lab.cyber.co.kr`` 은 kr 이라는 도메인 아래에 co가 있고, co 도메인 아래에 cyber가 있는 형식이다. 만약, 회사의 도메인이 ``example.co.kr``이라면 그 도메인의 아래에 ``sub1.exmaple.co.kr``, ``sub2.example.co.kr``과 같은 몇 개의 도메인을 만들어서 사업부마다 하위 도메인을 할당할 수가 있다.  

 ``www.cyber.co.kr``은 최상위에 kr라는 대한민국에 할당된 도메인이 있고, 하위에 국내의 도메인을 분류하기 위한 co라는 도메인이 있으며, 그 아래에 cyber라는 회사를 나타내는 도메인이 있는 것이다. 최하위의 www가 서버의 이름이다.  

### 담당 DNS 서버를 찾아 IP 주소를 가져온다

com이나 kr 이 최상위처럼 보이지만 사실 상위에 또 하나의 **루트 도메인**이라는 도메인이 있다. 우리가 DNS 서버에 접근하게 되면 가장 가까운 DNS 서버에 접근을 하게된다. 가장 가까운 서버에는 ``www.lab.glass.com``이라는 이름이 등록되어 있지 않기 때문에 루트 도메인의 DNS 서버로 클라이언트로부터 받은 조회 메시지를 전송한다(루트 도메인의 DNS서버에 관한 정보는 DNS 서버 소프트웨어와 함께 설정 파일로 배포되어 있으므로 DNS 서버 소프트웨어를 설치하면 자동으로 등록이 완료된다). 루트에서는 com 도메인의 DNS 서버에 조회 메시지를 보낸다. com은 glass로, glass는 lab으로 보낼 것이다. 이런 동작을 반복하면 결국에는 원하는 DNS 서버에 도달하게 된다. 그리고 거기에서 조회에 대한 답이 돌아온다.  

### DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다

현실에서는 상위와 하위의 도메인을 같은 DNS 서버에 등록하는 경우가 있다. 이 경우 상위의 DNS 서버에 조회하면 하위 DNS 서버를 한 개 건너뛰고, 다시 그 아래의 DNS 서버에 관한 정보가 돌아온다. 이 이유는 DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있기 때문이다.  

만약 캐시에 정보를 저장한 후 등록 정보가 변경되는 경우도 있으므로 캐시 안에 저장된 정보는 옳다고 단언할 수 없다. 따라서 DNS 서버에 등록하는 정보에는 유효기한을 설정하고, 캐시에 저장한 데이터의 유효 기간이 지나면 캐시에서 삭제한다. 또한 조회에 회답할 때 정보가 캐시에 저장된 것인지, 아니면 등록처 DNS 서버에서 회답한 것인지 알려준다.  

<br/>

## 프로토콜 스택에 메시지 송신을 의뢰한다

### 데이터 송수신 동작의 개요

 IP 주소를 조사했으면 IP 주소의 상대, 여기에서는 액세스 대상 웹 서버에 메시지를 송신하도록 OS의 내부에 있는 **프로토콜 스택**에 의뢰한다. 여기에서도 DNS 서버에 IP 주소를 조회할 때와 같이 Socket 라이브러리를 사용한다. 그러나 이전과 같이 하나를 호출하는 것이 아니라 순서대로 여러 프로그램을 호출해야한다는 차이점이 있다. 먼저 간략히 말하자면 클라이언트와 서버 간에 파이프를 만들고 해당 파이프를 통해 데이터를 송신한다.  

요점은 파이프의 양끝에 있는 데이터의 출입구다. 이 출입구를 **소켓**이라고 부른다. 서버 측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다리낟. 클라이언트 측에도 소켓을 만들고 소켓에서 파이프를 늘려 서버 측의 소켓에 연결 후 데이터 송수신 동작을 실행한다. 그 후 파이프를 분리하고 소켓을 말소하는 연결 끊기 동작을 하게된다. 이 동작들은 OS 내부의 프로토콜 스택에서 실행된다.  

### 소켓의 작성 단계

Socket 라이브러리를 이용해서 소켓을 만들게된다. 소켓이 생기면 **디스크립터**라는 것이 돌아오는데, 이것은 소켓을 식별하기 위한 것이다. 브라우저에는 1개의 소켓이 아니라 다수의 소켓이 존재할 수 있기 때문에 소켓을 식별하기 위해 디스크립터가 필요한 것이다.  

### 파이프를 연결하는 접속 단계

만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰한다. Socket 라이브러리의 connect라는 프로그램을 호출하여 실행하게된다.  
여기에서의 요점은 connect를 호출할 때 지정하는 디스크립터, 서버의 IP 주소, 포트 번호라는 세 가지 값이다. 디스크립터를 보고 프로토콜 스택이 어느 소켓을 서버측의 소켓에 접속할지 판단할 수 있다. 그리고 송수신하는 상대의 IP 주소를 통해 네트워크의 어느 컴퓨터인지를 식별한다. IP 주소만으로는 상대측의 소켓까지 지정할 수 없다. 이때 포트 번호를 이용해서 어느 컴퓨터의 어느 소켓과 접속할지를 분명히 지정할 수 있게 된다. 즉, 디스크립터는 컴퓨터 한 대의 내부에서 소켓을 식별하기 위해 사용하지만, 포트 번호는 접속 상대측에서 소켓을 식별하기 위해 사용한다.  

포트 번호는 URL에 쓰지 않는걸 보아서 DNS 서버에 조회하여 조사하는 것은 아니다. 서버 측의 포트 번호는 애플리케이션의 종류에 따라 미리 결정된 값을 사용한다는 규칙이 있을 뿐이다. 웹은 80번, 메일은 25번이라는 식이다. 그렇다면 포트 번호가 접속 상대측에서 소켓을 지정하기 위해 사용하는 것이라면 서버에서도 클라이언트 측의 소켓의 번호가 필요할 텐데 이 부분은 어떻게 되어 있을까? 클라이언트 측의 소켓의 포트 번호는 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라서 할당한다. 그리고 이 값을 프로토콜 스택이 접속 동작을 실행할 때 서버 측에 통지한다.  

connect를 호출하면 프로토콜 스택이 접속 동작을 실행한다. 그리고 상대와 연결되면 프로토콜 스택은 연결된 상대의 IP 주소나 포트 번호 등의 정보를 소켓에 기록한다. 이로써 데이터 송수신이 가능한 상태가 된다.  

### 메시지를 주고받는 송수신 단계

소켓이 상대측과 연결되면 소켓에서 데이터를 보내면 상대측의 소켓에 데이터가 도착한다. 그러면 애플리케이션은 소켓을 직접 다룰 수 있으므로 Socket 라이브러리를 통해 프로토콜 스택에 그 일을 의뢰한다. 그래서 write 이라는 프로그램을 호출한다. write를 호출할 때 디스크립터와 송신 데이터를 지정한다. 그러면 프로토콜 스택이 송신 데이터를 서버에게 송신한다. 이때 송신 데이터는 네트워크를 통해 전부 그대로 액세스 대상의 서버에도착한다. 서버는 수신 동작을 실행하여 받은 데이터의 내용을 조사하고 적절한 처리를 실행하여 응답 메시지를 반송한다.  

메시지 수신 시에는 read를 호출해서응답 메시지를 저장하기 위한 메모리 영역인 **수신 버퍼**를 지정하고 이곳에 저장하게 된다. 수신 버퍼에 메시지를 저장한 시점에서 메시지를 애플리케이션에 건네준다.  

### 연결 끊기 단계에서 송수신이 종료된다.

데이터 수신이 완료되면  웹 서버측에서 연결 끊기 동작을 실행하므로 먼저 웹 서버 측에서 close를 호출하여 연결을 끊는다. 이것이 클라이언트 측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어간다. 그리고 브라우저가 read로 수신 동작을 의뢰했을 때 read는 수신한 데이터를 건네주는 대신 송수신 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에 통지한다. 이로써 송수신이 종료되었다는 것을 알 수 있으므로 브라우저에서도 close를 호출하여 연결 끊기 단계에 들어간다(그러면 소켓 사이를 연결한 파이프와 같은 것이 분리되고 소켓도 말소된다).  

이것이 HTTP의 본래 동작인데, 데이터를 읽을 때마다 이 동작을 계속하기에는 너무 비효율적이므로 한 번 접속한 후 연결을 끊지 않고 복수의 리퀘스트와 응답 주고받기를 실행하는 방법이 마련되었다. HTTP 1.1에서 이 방법을 사용할 수 있다.  

***