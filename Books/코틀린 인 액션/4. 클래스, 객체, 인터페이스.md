# 클래스, 객체, 인터페이스

### 코틀린 인터페이스

```kotlin
interface Clickable {
    fun click()
}

class Button: Clickable {
    override fun click() {
        println("Button clicked")
    }
}
```

코틀린에서는 ``extends``, ``implements`` 를 사용하는 자바와는 달리 ``:`` 으로 클래스 상속과 인터페이스 구현을 모두 처리한다.  
자바는 ``@override`` 가 선택사항이지만, 코틀린은 ``override``를 붙이는 것이 필수다.  

```kotlin
class Button: Clickable {
    override fun click() {
        println("Button clicked")
    }
    
    fun showOff() = println("I'm clickable!")
}
```

``default`` 키워드를 붙여야 하는 자바와는 달리 코틀린은 바로 메서드를 추가하면 된다.  

```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!")
}

interface Focusable {
    fun showOff() = println("I'm focusable!")
}


class Button : Clickable, Focusable {
    override fun click() = println("Button clicked")
    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

위와 같이 동일한 함수명을 가진 인터페이스를 동시에 구현해야 하는 경우, ``super.showOff()`` 를 하면 어떤 메서드도 호출되지 않는다. 위의 코드와 같이 꺽쇠 안에 상위 타입의 이름을 지정해주어야 한다.  

``override fun showOff()  = super<Clickable>.showOff()`` 이런 식으로 지정하여 1개의 상위 인터페이스 메서드만 사용하게끔 할 수 있다.  

<Br/>

### open, final, abstract 변경자: 기본적으로 final

```kotlin
open class RichButton: Clickable {
    fun disable() {}        // final
    open fun animate() {}   // 열려있음
    override fun click() {} // 오버라이드한 메서드는 기본적으로 열려있음
}
```

코틀린은 기본적으로 class가 final이기 때문에 상속을 위해서는 ``open`` 키워드를 사용해주어야 한다.  

오버라이드한 메서드는 기본적으로 열려있기 때문에 ``final override fun click() {}`` 와 같이 ``final``을 따로 붙여서 닫을 수가 있다.  

기본적으로 ``final`` 이기 때문에 스마트 캐스트가 가능한 것이다.  

```kotlin
abstract class Animated {       // 인스턴스를 만들 수 없다 
    abstract fun animate()      // 반드시 오버라이드 해야함
    open fun stopAnimating() {} // open
    fun animateTwice() {}       // final
}
```

abstract은 반드시 오버라이드 해야한다.  

<Br/>

### 가시성 변경자: 기본적으로 공개

| 변경자               | 클래스 멤버                      | 최상위 선언                    |
| -------------------- | -------------------------------- | ------------------------------ |
| public (기본 가시성) | 모든 곳에서 볼 수 있다.          | 모든 곳에서 볼 수 있다.        |
| internal             | 같은 모듈 안에서만 볼 수 있다.   | 같은 모듈 안에서만 볼 수 있다. |
| protected            | 하위 클래스 안에서만 볼 수 있다. | (최상위 선언에 적용할 수 없음) |
| private              | 같은 클래스 안에서만 볼 수 있다. | 같은 파일 안에서만 볼 수 있다. |

```kotlin
internal open class TalkativeButton: Focusable {
    private fun yell() = println("Hey!")
    protected fun whisper() = println("Let's talk!")
}

fun TalkativeButton.giveSpeech() { // public
    yell()                          // private 접근 불가
    whisper()                       // protected 접근 불가
}
```

<br/>

### 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한

```kotlin
interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr
fun eval(e: Expr): Int = 
    when(e) {
        is Num -> e.value
        is Sum -> eval(e.right) + eval(e.left)
        else ->
            throw IllegalArgumentException("Unknown expression")
    }
```

위와 같은 경우 ``Expr`` 타입이 또 하나 생길 수 있고 분기 처리가 필요하고 버그가 발생할 수 있다.  

```kotlin
sealed class Expr {
    class Num(val value: Int) : Expr()
    class Sum(val left: Expr, val right: Expr) : Expr()
}
fun eval(e: Expr): Int =
    when(e) {
        is Expr.Num -> e.value
        is Expr.Sum -> eval(e.right) + eval(e.left)
    }
```

위와 같이 ``sealed`` 키워드를 통하여 해결한다.  
상위 클래스에 ``sealed`` 변경자를 붙이면 그 상위 클래스를 하위 클래스 정의를 제한할 수 있다.  
``sealed`` 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다.  

이제 새롭게 Expr 타입이 추가될 일이 없으므로 else 분기가 빠지게 된다.  

<br/>

