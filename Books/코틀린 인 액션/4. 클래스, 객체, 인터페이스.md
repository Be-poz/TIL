# 람다로 프로그래밍

### 람다와 컬렉션

```kotlin
data class Person(val name: String, val age: Int)

fun findTheOlderPerson(people: List<Person>) {
    var olderPerson: Person? = null
    for (person in people) {
        if (person.age > (olderPerson?.age ?: 0)) {
            olderPerson = person
        }
    }
    println(olderPerson)
}
```

위와 같이 컬렉션을 직접 검색하는 코드에서는 많은 코드가 들어있기 때문에 실수를 저지르기가 쉽다.  
비교 연산자를 잘못 사용하면 최댓값 대신 최솟값을 찾게된다.  

```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31))
people.maxOf { it.age }
```

이럴 때에 코틀린에서는 라이브러리 함수를 사용하면 된다. 컬렉션의 원소를 it이라는 인자로 받아서 비교에 사용할 값을 반환한다. 이런 식으로 단지 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 아래와 같이 멤버 참조로 대치할 수 있다.

```kotlin
people.maxOf(Person::age)
```

<br/>

### 람다 식의 문법

{ x: Int, y: Int -> x + y}  

항상 중괄호 사이에 위치하고 파라미터 -> 본문 의 형식이다.  

```kotlin
val sum = {x: Int, y: Int -> x + y}
println(sum(1, 2)) //3
```

```kotlin
people.maxOf({p:Person -> p.age })
```

위의 코드는 가독성이 떨어진다. 컴파일러가 문맥으로부터 유추할 수 있는 인자 타입을 굳이 적을 필요가 없다.  
마지막으로 인자가 단 하나뿐인 경우 굳이 인자에 이름을 붙이지 않아도 된다.  
코틀린에는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다.  

```kotlin
people.maxOf {p:Person -> p.age}
people.maxOf {p -> p.age}
```

위와 같이 변환이 가능하다.  

```kotlin
people.joinToString(separator = "", transform = { p: Person -> p.name })

people.joinToString("") { p:Person -> p.name }
```

위의 joinToString 에서도 마지막 인자가 람다 식이기 때문에 따로 뺄 수가 있다.  
그리고 컴파일러가 타입을 추론할 수 있기 때문에 타입을 생략할 수 있고, 인자가 하나이기 때문에 인자에 이름을 붙이지 않고 디폴트 이름인 it으로 표현할 수 있다.  

```kotlin
people.joinToString("") { p -> p.name}
people.joinToString("") { it.name }
```

<br/>

### 현재 영역에 있는 변수에 접근

```kotlin
fun printMessagesWithPrefix(messages: Collection<String>, prefix: String) {
    messages.forEach {
        println("$prefix $it")
    }
}

fun printProblemCounts(responses: Collection<String>) {
    var clientErrors = 0
    var serverErrors = 0
    responses.forEach { 
        if (it.startsWith("4")) {
            clientErrors++
        } else if (it.startsWith("5")) {
            serverErrors++
        }
    }
}
```

위와 같이 람다 내부에서 바깥 함수의 로컬 변수에 접근할 수도 있고 그 값을 변경할 수도 있다.  
자바에서는 final이 붙은 불변인 변수만 접근이 가능했고 값 변경이 당연히 불가능했다.  

람다 안에서 사용하는 외부 변수를 ''람다가 포획한 변수'' 라고 부른다.  
기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다. 하지만 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있다. 포획된 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.  

<br/>

### 멤버 참조

코틀린에서는 함수를 값으로 바꿀 수 있다. 이때 이중 콜론을 사용한다.  
``val getAge = Person::age`` ::를 사용하는 식을 멤버 참조라고 부른다.  

``val getAge = { person:Person -> person.age }``와 같은 람다 식을 간략하게 표현한 것이다.  

```kotlin
fun main(args: Array<String>) {
    fun salute() = println("Salute!")
    run(::salute)
}
```

위와 같이 최상위에 선언된 함수나 프로퍼티를 참조할 수도 있다.  

```kotlin
val action = { person:Person, message: String -> sendEmail(person, message)}
val nextAction = ::sendEmail

data class Person(val name: String, val age: Int)
val createPerson = ::Person
```

위와 같이 람다 함수에 대한 참조를 제공하거나 생성자 참조를 만들 수도 있다.  

```kotlin
fun Person.isAdult() = age >= 21
val predicate = Person::isAdult
```

확장 함수 또한 멤버 참조 구문을 사용할 수도 있다.  

<br/>

### 필수적인 함수: filter와 map

```kotlin
val list = listOf(1, 2, 3, 4)

list.filter { it % 2 == 0 } // [2, 4]
list.map { it * 2 } // [2, 4, 6, 8]

people.filter { it.age > 30 }.map { it.name } // [Bob]
```

<br/>

### all any, count, find: 컬렉션에 술어 적용

```kotlin
val people = listOf(Person("Alice", 27), Person("Bob", 31))
val canBeInClub27 = { p: Person -> p.age <= 27 }

println(people.all(canBeInClub27)) // false
println(people.any(canBeInClub27)) // true
println(people.count(canBeInClub27)) // 1
println(people.find(canBeInClub27)) // Person(name=Alice, age=27)
```

<br/>

### groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경

```kotlin
val people = listOf(Person("Alice", 31), Person("Bob", 29), Person("Carol", 31))
println(people.groupBy { it.age }) 
// {31=[Person(name=Alice, age=31), Person(name=Carol, age=31)], 29=[Person(name=Bob, age=29)]}
```

<br/>

### flatMap과 faltten: 중첩된 컬렉션 안의 원소 처리

```kotlin
val strings = listOf("abc", "def")
println(strings.flatMap { it.toList() }) // [a, b, c, d, e, f]
```

flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다.  

```kotlin
println(listOf(
    Book("Thursday Next", listOf("Jasper Fforde")),
    Book("Mort", listOf("Terry Pratchett")),
    Book("Good Omens", listOf("Terry Pratchett", "Neil Gaiman"))
).flatMap { it.authors }) // [Jasper Fforde, Terry Pratchett, Terry Pratchett, Neil Gaiman]
```

