# 제네릭스

## 제네릭 타입 파라미터

제네릭스를 사용하면 **타입 파라미터**를 받는 타입을 정의할 수 있다. 제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 **타입 인자**로 치환해야 한다.  

``fun <T> List<T>.slice(indices: IntRange): List<T>``  

앞에 <T>로 타입 파라미터를 선언했고, 타입 파라미터가 수신 객체와 반환 타입에 쓰인다.  

```kotlin
  val letters = ('a'..'z').toList()
  println(letters.slice<Char>(0..2))
  println(letters.slice(10..13))
```

2번째 문장과 같이 타입 인자를 명시적으로 지정할 수 있지만, 3번째 문장은 컴파일러가 T는 Char라는 사실을 알아서 추론한다.  

```kotlin
val authors = listOf("Dmitry", "Svetlana")
val readers = mutableListOf<String>("Dmitry", "Svetlana")
readers.filter { it !in authors }
```

``fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>`` 의 형태로 동작하여 알아서 String이 들어간 List임을 추정했다고 볼 수 있다.  

```kotlin
val <T> List<T>.penultimate: T
    get() = this[size - 2]
```

위와 같이 제네릭을 이용하여 확장 프로퍼티를 사용할 수도 있다.  

```kotlin
interface List<T> {
  operator fun get(index: Int): T
}

class StringList: List<String> {
  override fun get(index: Int): String...
}

class ArrayList<T>: List<T> {
  override fun get(index: Int): T ...
}
```

위와 같이 클래스를 제네릭하게 만들 수도 있다.  

``fun <T: Number> List<T>.sum(): T`` 이렇게 상한 타입을 둘 수도 있다.  

```kotlin
fun <T> ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable {
    if (!seq.endsWith('.')) {
        seq.append('.')
    }
}
```

한 가지 타입의 제약이 아닌 그 이상의 타입 제한을 두어야 하는 경우 위의 코드와 같이 ``where``을 이용하여 처리한다.  

```kotlin
class Processor<T> {
    fun process(value: T) {
        value?.hashCode()
    }
}
```

위와 같은 경우에 T는 null이 들어올 수 있기 떄문에 안전한 호출을 사용해야 한다.  

```kotlin
class Processor<T: Any> {
    fun process(value: T) {
        value?.hashCode()
    }
}
```

이럴 때 널 가능성을 제외한 아무런 제약도 필요 없다면 ANy? 대신 Any를 상한으로 사용해서 널 가능성을 제외시키면 된다.  

``val nullableStringProcessor = Processor<String?> ()`` 왼쪽의 경우 문제가 생긴다.  
String?가 Any의 자손 타입이 아니고, Any?는 Any 보다 덜 구체적인 타입이다.  

<br/>

## 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 *를 포함시켜야 한다. 인자를 알 수 없는 제네릭 타입을 표현할 때 사용한다.  

```kotlin
fun printSum(c: Collection<*>) {
    val intList = c as? List<Int> ?: throw IllegalArgumentException("List is expected")
    println(intList.sum())
}

printSum(listOf(1, 2, 3))
printSum(setOf(1, 2, 3))
```

2번째 구문에서 Unchecked cast: List<*> to List<Int> 경고가 발생하지만 컴파일에는 문제없다.  

하지만, setOf(1,2,3)인 경우에는 리스트가 아니므로 예외가 발생한다.  

<Br/>

``fun <T> isA(value: Any) = value is T`` 코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워진다. 따라서 제네릭 클래스의 인스턴스가 있어도 그 인스턴스를 만들 때 사용한 타입 인자를 알아낼 수 없다. 제네릭 함수의 타입 인자도 마찬가지다. 제네릭 함수가 호출되도 그 함수의 본문에서는 호출 시 쓰인 타입 인자를 알 수 없다.  

하지만 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.  

```kotlin
inline fun <reified T> isA(value: Any) = value is T

println(isA<String>("abc"))
```

타입 파라미터에 ``reified``를 지정하면 실행 시점에 타입 인자를 사용할 수 있다.  

```kotlin
public inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {
    for (element in this) if (element is R) destination.add(element)
    return destination
}

println(listOf("one", 2, "three").filterIsInstance<String>())
//[one, three]
```

Collections에서 기본적으로 제공해주는 함수이다. 타입 인자를 사용해 타입이 일치하는 원소만을 추려낼 수 있다.  

인라인 함수에서만 실체화한 타입 인자를 쓸 수 있는 이유는 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입하는데, 컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다. 따라서 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있는 것이다.  

인라인 함수를 사용할 때에는 성능을 생각해서 조심해서 사용해야 한다. 함수가 커지면 실체화한 타입에 의존하지 않는 부분을 별도의 일반 함수로 뽑아내는 편이 낫다.  

<br/?>

## 변성: 제네릭과 하위 타입

