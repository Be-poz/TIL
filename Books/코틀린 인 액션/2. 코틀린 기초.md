# 코틀린 기초

### 함수

```kotlin
fun max(a: Int, b: Int): Int {
  return if (a > b) a else b
}
```

함수 선언할 때에는 fun 키워드 이후 파라미터 목록, 그 다음 반환 타입을 작성한다.  

위의 식을  

``fun max(a: Int, b: Int): Int = if (a > b) a else b`` 로 표현할 수도 있다.  
본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**,  
등호와 식으로 이뤄진 함수를 **식이 본문인 함수** 라고 부른다.  

위의 식에서 컴파일러가 타입을 분석해 **타입 추론**을 하기 때문에 반환 타입을 생략해 줄 수가 있다.  
**식이 본문인 함수의 변환 타입만 생략 가능** 하다.  

<br/>

### 변수

```kotlin
val answer = 42
val answer: Int = 42
val answer: Int
answer = 42
```

변수 또한 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 타입을 지정해준다.  
그렇기 때문에 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해주어야 한다.  

val은 value라는 뜻이고 변경 불가능한 final한 변수다.  
var은 variable이라는 뜻이고 변경 가능한 일반 자바 변수라고 보면 된다.  

<br/>

### 문자열 템플릿

문자열 내부에 ``$`` 를 사용해 변수를 가져다 사용할 수 있다.  

```kotlin
val name = "kang"
println("hi $name")

val name = "kang"
println("hi ${if (name.length > 3) name else "other Name"}")
```

복잡한 식은 중괄호를 이용해 표현할 수 있다. 중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다.  

<Br/>

### 프로퍼티

자바에서는 필드와 접근자를 한데 묶어 프로퍼티 라고 부른다.  
코틀린 프로퍼티는 자바의 필드와 접근자 메서드를 완전히 대신한다.  

```kotlin
class Person(
    val name: String,
    var age: Int
)
```

위와 같이 선언하는 경우에 val은 변경이 불가능 하기 때문에 읽기 전용 프로퍼티고,  
var은 그렇지 않으므로 getter, setter를 만들어낸다.  

두 프로퍼티 모두 필드 생성 시에는 비공개로 생성을 한다.  
``person.name`` 이런식으로 이름을 직접적으로 사용해도 내부적으로는 getter를 호출해준다.  

<Br/>

### 커스텀 접근자

```kotlin
fun main(args: Array<String>) {
    val p = Person("kang", 10)
    println(p.isNameKang)
}

class Person(
    val name: String,
    var age: Int
) {
    val isNameKang: Boolean
        get() = name == "kang"
}
```

``get()``, ``set()`` 을 이용해서 커스텀한 접근자를 사용할 수도 있다.  

``isNameKang`` 이라는 프로퍼티를 두지 않고 함수로 정의해도 다른점은 없다.  
일반적으로 클래스의 특성을 정의하고 싶다면 프로퍼티로 그 특성을 정의해야 한다.  

setter는 다음과 같이 사용하면 된다.  

```kotlin
class Person(val name: String) {
    var age: Int = 0
        set(value) {
            if (value < 0) {
                throw IllegalArgumentException("Age cannot be negative")
            }
            field = value
        }
    
    val isNameKang: Boolean
        get() = name == "kang"
}

fun main() {
    val person = Person("kang")
    person.age = 30
    
    println("Name: ${person.name}, Age: ${person.age}, isNameKang: ${person.isNameKang}")
    
    person.age = -10
}

Name: kang, Age: 30, isNameKang: true
Exception in thread "main" java.lang.IllegalArgumentException: Age cannot be negative
```

그렇다면 age 자체를 생성자에서 바로 사용하고 싶다면 다음과 같은 방식으로 구현을 하면 된다.  

```kotlin
class Person(val name: String, var age: Int = 0) {
    init {
        if (age < 0) {
            throw IllegalArgumentException("Age cannot be negative")
        }
    }
    
    val isNameKang: Boolean
        get() = name == "kang"
}
```

해당 프로퍼티의 값을 변경할 때 추가적인 검증 작업을 수행하고 싶을 때 사용하면 된다고 보면된다. 

<br/>

### enum

```kotlin
enum class Color(
    val r: Int, val g: Int, val b: Int
) {
    RED(255, 0, 0),
    ORANGE(255, 165,0),
    YELLOW(255, 255, 0);

    fun rgb() = (r * 256 + g) * 256 + b
}
```

