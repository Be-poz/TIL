# 3. 모든 객체의 공통 메서드

## equals는 일반 규약을 지켜 재정의하라

다음에서 열거한 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선이다.  

* 각 인스턴스가 본질적으로 고유하다.

  Thread가 좋은 예이다. Object의 equals 메서드는 이러한 클래스에 맞게 구현됐다.

* 인스턴스의 '논리적 동치성'을 검사할 일이 없다.

* 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.

  예를들면 Set 구현체는 AbstractSet이 구현한 equals를 상속받아 사용한다.

* 클래스가 private이거나 package-prviate이고 equals 메서드를 호출할 일이 없다.

equals를 재정의해야 할 때는 논리적 동치성을 확인해야 하는데 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.  

<br/>

equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 한다.  

* **반사성(reflexivity)** : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true 다.
* **대칭성(symmertry)** : null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true면 y.equals(x)도 true다.
* **추이성(transivity)** : null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.
* **일관성(consistency)** : null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
* **null- 아님** : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.

<br/>

클래스가 불변이든 가변이든 **equals**의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.  
양질의 equals 메서드 구현 방법은 다음과 같은 단계를 가진다.  

1. **== 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.** 자기 자신이면 true를 반환한다. 이는 단순한 성능 최적화용이며, 비교 작업이 복잡할 때 크게 도움이 된다.
2. **instanceof 연산자로 입력이 올바른 타입인지 확인한다. ** 그렇지 않다면 false를 반환한다.
3. **입력을 올바른 타입으로 형변환한다.** 앞서 2번에서 instanceof 검사를 했기 때문에 이 단계는 100% 성공한다.
4. **입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.** 모든 필드가 일치하면 true를, 하나라도 다르면 false를 반환한다. 2단계에서 인터페이스를 사용했다면 입력의 필드 값을 가져올 때도 그 인터페이스의 메서드를 사용해야 한다.

  

float와 double을 제외한 기본 타입 필드는 ==연산자로 비교하고, 참조 타입 필드는 각각의 equals 메서드로, float와 double 필드는 각각 정적 메서드인 Float.compare(float, float)와 Double.compare(double, double)로 비교한다. 그 이유는 특수한 부동소수 값 등을 다뤄야 하기 때문이다.  

어떤 필드를 먼저 비교하느냐가 equals의 성능을 좌우하기도 한다. 다를 가능성이 더 크거나 비교하는 비용이 싼 필드를 먼저 비교하자. 동기화용 락(lock) 필드 같이 객체의 논리적 상태와 관련 없는 필드는 비교하면 안 된다.  

**equals를 다 구현했다면 대칭적인지 추이성이 있는지 일관적인지 확인하자.**  

* equals를 재정의할 땐 hashCode도 반드시 재정의하자

* 너무 복잡하게 해결하려 들지 말자

* Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.

  ```java
  public boolean equals(MyClass o) {...}
  ```

  이 메서드는 Object.equals를 재정의한 게 아니다. 입력 타입이 Object가 아니므로 재정의가 아니라 다중정의한 것이다. 타입을 구체적으로 명시한 equals는 오히려 해가 된다. 이 메서드는 **하위 클래스에서의 @Override 어노테이션이 긍정 오류를 내게 하고 보안 측면에서도 잘못된 정보를 준다. 이번 예제 코드에서처럼 @Override 어노테이션을 일관되게 사용하면 이러한 실수를 예방할 수 있다.(오버라이드는 시그니처가 동일해야 하기 때문에 Object를 매개변수로 받는 것을 지켜주기 때문인 것 같다.)**  

<br/>

## equals를 재정의하려거든 hashCode도 재정의하라

**equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.** 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.  

* equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
* equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
* equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

**hashCode 재정의를 잘못했을 때 크게 문제가 되는 조항은 두 번째다. 즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.**  

**성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다.** 속도야 빨라지겠지만, 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어뜨릴 수도 있다.  

**hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다.**  

HashMap과 HashSet에서 문제를 일으키는 이유는 여기에서 확인하자. [링크](https://github.com/Be-poz/TIL/blob/master/Java/equals%2C%20%3D%3D%2C%20hashCode%20%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%99%80%20%EC%9E%AC%EC%A0%95%EC%9D%98%20%EC%8B%9C%EC%A0%90%EC%97%90%20%EB%8C%80%ED%95%B4.md)  

<br/>

## toString을 항상 재정의하라

기본 toString은 ``클래스_이름@16진수로_표시한_해시코드``를 반환한다. 이를 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환하게끔 해야한다.  

실전에서 **toString은 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.**  

단점도 있다. 포맷을 한 번 명시하면 (그 클래스가 많이 쓰인다면) 평생 그 포맷에 얽메이게 된다. 이를 사용하는 프로그래머들이 그 포맷에 맞춰 파싱하고, 새로운 객체를 만들고, 영속 데이터로 저장하는 코드를 작성할 것이다.  

포맷 명시 여부와 상관없이 **toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.**  
그렇지 않으면 이 정보가 필요한 프로그래머는 toString의 반환값을 파싱할 수밖에 없다. 성능이 나빠지고, 필요하지도 않은 작업이다. 게다가 향후 포맷을 바꾸면 시스템이 망가지는 결과를 초래할 수 있다.  

<br/>

## clone 재정의는 주의해서 진행하라

**clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.** 그래서 Stack의 clone 메서드는 제대로 동작하려면 스택 내부 정보를 복사해야 하는데, 가장 쉬운 방법은 elements 배열의 clone을 재귀적으로 호출해주는 것이다.  

<br/>

## Comparable을 구현할지 고려하라

compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다.  
Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서가 있음을 뜻한다.  

자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입이 Comparable을 구현했다.  
알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.  

compareTo 메서드의 일반 규약은 equals의 규약과 비슷하다. 규약을 지키지 못하면 비교를 활용하는 클래스와 어울리지 못한다. 예로들면 Treeet, TreeMap, 검색과 정렬 알고리즘을 활용하는 유틸리티 클래스인 Collections와 Arrays가 있다.  

* Comparable을 구현한 클래스는 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) 여야 한다. 따라서 x.compareTo(y)는 y.compareTo(x)가 예외를 던질 때에 한해 예외를 던져야 한다.
* Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.equals(y)) 여야 한다. 

결론은, 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스터스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다. compareTo 메서드에서 필드의 값을 비교할 때 < 와 > 연산자는 쓰지 말아야 한다. 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.  

***