# 4. 예외

* 예외 발생 시에 catch 블록을 써서 잡아내는 것까지는 좋은데 그리고 아무것도 하지 않고 별문제 없는 것처럼 넘어가 버리는 건 정말 위험한 일이다.  

  ```java
  } catch (SQLException e) {
  	System.out.println(e)
  }
  
  or
    
  } catch (SQLException e) {
    e.printStackTrace();
  }
  ```

  이것 또한 문제다! 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명히 통보돼야 한다.  

  ```java
  } catch (SQLException e) {
    e.printStackTrace();
    System.exit(1);
  }
  ```

  차라리 이렇게 만드는 것이 백 배 낫다. 

* 모든 메소드에 ``throws Exception``을 붙이는 것은 무책임한 코딩이다. 정말 무엇인가 실행 중에 예외적인 상황이 발생할 수 있다는 것인지, 아니면 그냥 습관적으로 복사해서 붙여놓은 것인지 알 수가 없다. 결국 이런 메소드를 사용하는 메소드에서도 역시 throws Exception을 따라서 붙이는 수 밖에 없다. 결과적으로 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당한다.  

* 자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.

  * Error : 시스템에 비정상적인 상황이 발생한 경우에 사용됨. 주로 VM에서 발생시킴. ``OutofMemory``, ``ThreadDeath`` 같은거임. 애플리케이션에서는 이런 에러에 대한 처리는 신경 쓰지 않아도 됨.
  * Exception and Checked Exception : checked 예외의 경우에는 반드시 예외를 처리하는 코드를 함께 작성해야 한다. catch문으로 잡든지, 아니면 다시 throws를 정의해서 메소드 밖으로 던져야 한다.
  * RuntimeException and Unchecked Exception : 예외 처리를 강제하지 않는다. ``NPE``, ``IllegalArgument`` 등이 있다. 

* 예외처리 방법

  * 예외 복구 : 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다.  
  * 예외 회피 : 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것이다. 예외를 자신이 처리하지 않고 회피하는 방법이다. catch로 잡아서 예외가 발생하지 않은 것처럼 만드는 경우는 회피를 한 것이 아니다. 예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다. 콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 있어야 한다.
  * 예외 전환 : 발생한 예외가 아닌 적절한 예외로 전환해서 메소드 밖으로 던지는 것이다. 예외 전환은 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우에 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서 사용된다. API가 발생하는 기술적인 로우레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것이다. 보통 전환하는 예외에 원래 발생한 예외를 담아서 중첩 예외로 만드는 것이 좋다.

* 예외처리 전략

  * 런타임 예외의 보편화 : 독립형 애플리케이션과 달리 서버의 특정 계층에서 예외가 발생했을 때 작업을 일시 중지하고 사용자와 바로 커뮤니케이션하면서 예외상황을 복구할 수 있는 방법이 없다. 차라리 애플리케이션 차원에서 예외상황을 미리 파악하고, 예외가 발생하지 않도록 차단하는 게 좋다. 차라리 예외가 발생하지 않도록 미리 차단하는게 좋고, 프로그램의 오류나 외부 환경으로 인해 예외가 발생하는 경우라면 빨리 해당 요청의 작업을 취소하고 서버 관리자나 개발자에게 통보해주는 편이 낫다. 요즘은 항상 복구할 수 있는 예외가 아니라면 일단 언체크 예외로 만드는 경향이 있다.
  * 런타임 예외를 만든경우에는 사용에 더 주의해야 한다. 컴파일러가 예외처리를 강제하지 않으므로 신경 쓰지 않으면 예외상황을 충분히 고려하지 않을 수도 있기 때문이다.
  * 런타임 예외는 복구할 수 있는 예외가 없다고 가정하고 예외가 생겨도 어차피 런타임 예외이므로 시스템 레벨에서 알아서 처리해줄 것이고, 꼭 필요한 경우는 런타임 예외이므로 시스템 레벨에서 알아서 처리해줄 것이고, 꼭 필요한 경우는 런타임 예외라도 잡아서 복구하거나 대응해줄 수 있으니 문제 될 것이 없다는 측면에서 낙관적인 예외처리 기법이라고 할 수 있다.

* ``JdbcTemplate`` 에서는 체크드 예외인 ``SQLException``을 런타임 예외인 ``DataAccessException``으로 포장해서 던져준다. 사용자는 꼭 필요한 경우에만 이 런타임 예외를 잡아서 처리하면 된다.

* SQL은 DB별로 다르므로 사용하는 DB가 변경이 되는 경우 적지 않은 수정이 일어난다. 즉 해당 DAO는 특정 DB에 종속적인 코드가 되고 만다. 결국 사용할 수 있는 방법은 DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜 바꿔 쓸 수 있게 하는 것이다.

* DB별로 에러코드가 다르기 때문에 DB 종류에 상관없이 동일한 상황에서 일관된 예외를 전달받을 수 있다면 효과적인 대응이 가능하다. 스프링은 DB별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 매핑정보 테이블을 만들어두고 이를 이용한다.

* ``DataAccessException``은 JDBC의 ``SQLException``을 전환하는 용도로만 만들어진 건 아니다. 의미가 같은 예외라면 데이터 엑세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어준다. 데이터 엑세스 기술에 독립적인 추상화된 예외를 제공하는 것이다.

* 여러 기술을 사용하고 하나의 인터페이스를 사용하려고 해도 기술 별로 던지는 예외가 다르기에 정상적으로 사용하기가 어렵다.  

  ```java
  public void add(User user) throws PersistenceException; // JPA
  public void add(User user) throws HibernateException; // HIbernate
  public void add(User user) throws JdoException; // JDO
  ```

  다행히 JDBC 보다 늦게 등장한 JDO, Hibernate, JPA 등의 기술은 ``SQLException`` 같은 체크 예외 대신 런타임 예외를 사용한다. ``SQLException``을 던지더라도 메소드 내에서 런타임 예외로 포장해준다면 처음 의도했던 대로 다음과 같이 선언해도 된다. ``public void add(User user)``. 하지만 각 기술별로 동일한 상황에서도 던지는 예외가 다르기 때문에 클라이언트 입장에서는 DAO의 사용 기술에 따라서 예외 처리 방법을 달리해야한다. 결국 DAO의 기술에 의존적이 될 수 밖에 없다. 인터페이스로 추상화하고, 일부 기술에서 발생하는 체크 예외를 런타임 예외로 전환하는 것만으론 불충분하다.

* 이를 위해 계층구조를 만들어서 사용 기술에 독립적인 일관성 있는 예외를 던질 수 있게끔 하였다. 결국 인터페이스 사용, 런타임 예외 전환과 함께 ``DataAccessException``예외 추상화를 적용함현 데이터 엑세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수가 있다.

* ``DataAccessException``이 기술에 상관없이 어느 정도 추상화된 공통 예외로 변환해주긴 하지만 근본적인 한계 때문에 완벽하다고 기대할 수는 없다. 따라서 사용에 주의를 기울여야 한다. DataAccessException을 잡아서 처리하는 코드를 만들려고 한다면 미리 학습 테스트를 만들어서 실제로 전환되는 예외의 종류를 확인해둘 필요가 있다.

***