# 3. 템플릿

* 리소스 반납을 위해 try-catch-finally 를 사용해서 반납을 한다고 해도 그 코드가 수백줄이 되면 문제가 발생했을 시에 원인이 되는 부분을 찾기가 굉장히 어려울 것이다. 이것을 해결하기위해 템플릿 메소드 패턴을 적용할 수도 있지만 로직마다 새로운 클래스를 만들어야 하고 확장구조가 클래스를 설계하는 시점에서 고정되어 버린다는 단점이 있다. 전략 패턴을 사용하면 이를 해결할 수가 있다.
* 전략 패턴을 사용해도 다이나믹하게 DI를 해준다는 점을 제외하면 템플리 메소드 패턴과 큰 차이점이 없다. 로직마다 클래스를 생성해줘야 한다는 점은 여전하다. 이를 해결하기 위해서 내부 클래스와 익명 내부 클래스를 이용할 수 있다. 이 예제에서는 추상 메서드가 1개이므로 함수형 인터페이스로 사용해서 람다식 표현도 가능하다.
* 인터페이스가 아닌 구체 클래스를 주입해준다고 하더라도 DI라고 볼 수 있다. 싱글톤 레지스트리에서 관리하는 싱글톤 빈이 되고, 다른 빈을 DI받기 위해서는 본인도 빈이 되어야 하기 때문이다. 정말 필요하다면 인터페이스가 아닌 구체 클래스를 이렇게 등록해도 되지만, 인터페이스를 만들기 귀찮다는 이유로 그냥 클래스를 사용하자는 건 잘못된 생각이다.
* 수동 DI를 하는 방법도 있다. ``UserDao``에서 ``JdbcContext``를 사용하기 위해서 이전에는 그냥 구체 클래스를 빈으로 등록했지만 new를 통해서 수동 DI를 하는 것이다. 문제는 ``JdbcContext`` 내부에 ``DataSource``가 주입되어있는데 이 경우에 어떻게 처리하냐는 것인데 ``DataSource``또한 ``UserDao``에서 빈을 받아와서 ``JdbcContext``에게 수정자 메서드로 주입해주면 된다.
* 위의 전략패턴과 같은 방식을 스프링에서는 템플릿/콜백 패턴이라고 부른다. 전략 패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부른다. 정의하자면, 템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙인 이름이다. 콜백은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 말한다. 단일 전략 메서드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어 사용하고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식이다.
* 제네릭스를 이용해 더 유연하게 템플릿/콜백 패턴을 구축할 수 있다.
* 우리가 자주 쓰는 ``JdbcTemplate``대표적인 템플릿/콜백을 잘 활용한 예이다.

***

