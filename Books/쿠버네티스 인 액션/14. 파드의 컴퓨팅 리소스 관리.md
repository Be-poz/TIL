# 파드의 컴퓨팅 리소스 관리

## 파드 컨테이너의 리소스 요청

파드를 생성할 때 컨테이너가 필요로 하는 CPU와 메모리 양과 사용할 수 있는 엄격한 제한을 지정할 수 있다.  

<br/>

### 리소스 요청을 갖는 파드 생성하기

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: requests-pod
spec:
  containers:
  - image: busybox
    command: ["dd", "if=/dev/zero", "of=/dev/null"]
    name: main									# 주 컨테이너에 리소스 요청을 지정한다.
    resources:
      requests:
        cpu: 200m								# 컨테이너는 200밀리코어를 요청한다. (하나의 CPU 코어 시간의 1/5)
        memory: 10Mi						# 컨테이너는 10Mi(Mebibyte)의 메모리를 요청한다.
```

1/5 CPU 코어를 필요로 한다고 적어놨는데 이런 파드/컨테이너 5개를 CPU 코어 하나에서 충분히 빠르게 실행할 수 있다.  

CPU 요청을 지정하지 않으면 컨테이너에서 실행 중인 프로세스에 할당되는 CPU 시간에 신경 쓰지 않는다는 것과 같다. 최악의 경우 CPU 시간을 전혀 할당받지 못할 수 있다. 시간이 중요하지 않은 우선순위가 낮은 배치 작업은 괜찮지만 사용자 요청을 처리하는 컨테이너에는 분명 적합하지 않다.  

10Mi의 메모리를 요청함으로써 컨테이너 내부에 실행 중인 프로세스가 최대 10Mi의 메모리를 사용할 것을 예상할 수 있다.  

파드 생성 후 ``k exec -it requests-pod top``을 실행하여 프로세스의 CPU 소비량을 확인할 수 있다.  

<br/>

### 리소스 요청이 스케줄링에 미치는 영향

리소스 요청을 하면 스케줄러는 충분한 리소스를 가진 노드만을 고려한다. 부합하지 않은 노드에는 스케줄링 하지 않는다.  

#### 파드가 특정 노드에 실행할 수 있는지 스케줄러가 결정하는 방법

스케줄러는 스케줄링하는 시점에 각 개별 리소스가 얼마나 사용되는지 보지 않고, 노드에 배포된 파드들의 리소스 요청량의 전체 합만을 본다는 것이다.  
파드가 요청한 것보다 적게 사용할지라도 실제 리소스 사용량에 기반해 다른 파드를 스케줄링한다는 것은 이미 배포된 파드에 대한 보장을 깨뜨릴 수 있다.  

<img width="812" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/9bf359be-404a-4527-8306-b9bda2593a40">

#### 스케줄러가 파드를 위해 최적의 노드를 선택할 때 파드의 요청을 사용하는 방법

11장에서 스케줄러는 파드에 맞지 않은 노드를 제거하기 위해 노드의 목록을 필터링한 다음 설정된 우선순위 함수에 따라 남은 노드의 우선순위를 지정한다고 했다. 다른 여러 우선순위 함수 중에서, 두 개의 우선순위 함수가 요청된 리소스 양에 기반해 노드의 순위를 정한다.  

LeastRequestedPriority와 MostRequestPriority이다. 첫 번째 함수는 요청된 리소스가 낮은 노드를 선호하는 반면, 두 번째 함수는 그와 정반대로 요청된 리소스가 가장 많은 노드를 선호한다.  

스케줄러는 이들 함수 중 하나만을 이용하도록 설정된다. 일반적으로 노드들의 세트가 있는 경우 CPU 부하를 전체 노드에 고르게 분산하기를 원할 것이다.  
하지만 필요하면 언제든 노드를 추가하거나 제거할 수 있는 클라우드 인프라에서 실행하는 경우는 다르다. 스케줄러가 MostRequestedPriority 함수를 사용하도록 설정하면 쿠버네티스는 파드가 요청한 CPU와 메모리 양을 제공하면서도 가장 적은 수의 노드를 사용하도록 보장한다. 파드를 일부 노드에 많이 스케줄링해 특정 노드를 비울 수 있고 제거할 수 있다. 각 노드별로 비용을 지불하므로 이렇게 비용을 절감할 수 있다.  

#### 노드의 용량 검사

``k describe nodes``로 노드 리소스를 확인한다. ``Capacity.memory``에서 노드의 전체 용량을 확인할 수 있고, ``Allocatable.memory``를 통해 파드에 할당 가능한 리소스를 확인할 수 있다. 이제 cpu 800m, memory 20Mi의 파드를 하나 더 생성해보자.  

#### 어느 노드에도 실행할 수 없는 파드 생성

현재 2개의 파드가 배포됐고 총 1000 밀리코어, 정확히 1코어를 요청했다. 따라서 추가적인 파드에 1,000 밀리코어가 사용 가능해야 한다.  

이제 cpu 1, memory 20Mi인 3번째 파드를 배포해보자. k get po를 해보면 Pending 상태인 것을 확인할 수 있을 것이고 describe 해보면 cpu가 부족해 스케줄링이 실패했다는 문구를 확인할 수가 있다.  

#### 파드가 스케줄링되지 않은 이유 확인

<img width="696" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/ff733d25-c978-4e27-8dfc-3e2780b81790">

요청한 CPU는 1000m인데 1275m으로 275밀리코어가 더 많다. 확인해보면 kube-system 네임스페이스의 3개의 파드 때문인 것을 알 수가 있다.  

#### 파드가 스케줄링될 수 있도록 리소스 해제

파드는 적절한 양의 CPU가 남아 있는 경우에만 스케줄링이 된다. 2번째 파드를 삭제하면 스케줄러는 삭제를 통지받고 두 번째 파드가 종료되자마자 세 번째 파드를 스케줄링할 것이다.  

<br/>

### CPU 요청이 CPU 시간 공유에 미치는 영향

<img width="723" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/08ea3750-8863-4ccd-8536-090b2f39f1b9">

위와 같이 동작한다. 그리고 한 컨테이너가 CPU를 최대로 사용하려는 순간 나머지 파드가 유휴 상태에 있다면 첫 번째 컨테이너가 전체 CPU 시간을 사용할 수 있다. 결국 아무도 사용하지 않는다면 사용 가능한 모든 CPU를 사용하는 것이 상식이다.  

<br/>

### 사용자 정의 리소스의 정의와 요청

쿠버네티스를 사용하면 사용자 정의 리소스를 노드에 추가하고 파드의 리소스 요청으로 사용자 정의 리소스를 요청할 수 있다.  

먼저 노드 오브젝트의 capacitty 필드에 값을 추가해 쿠버네티스가 사용자 정의 리소스를 인식하도록 해야 한다. 이는 PATCH HTTP 요청을 수행해 이뤄진다. 리소스 이름은 kubernetes.io 도메인으로 시작하지 않는 이상 example.org/my-resource와 같이 무엇이든 될 수 있다. 수량은 반드시 정수여야 한다. 이 값은 capacity 필드에서 allocatable 필드로 자동으로 복사된다.  

그런 다음 파드를 생성할 때 동일한 리소스 이름과 수량을 컨테이너 스펙의 resources.requests 필드로 지정하거나 이전 예제와 같이 kubectl run에 --requests를 사용해 지정한다.  

사용자 정의 리소스의 예로는 노드에 사용 가능한 GPU 단위 수가 있다. GPU 사용을 요구하는 파드는 요청에 이를 지정한다. 스케줄러는 할당되지 않은 GPU가 적어도 하나가 있는 노드에만 파드가 스케줄링되도록 보장한다.  

<br/>

## 컨테이너에 사용 가능한 리소스 제한

