# 파드: 쿠버네티스에서 컨테이너 실행

## 파드 소개

### 파드 이해하기

* 파드의 모든 컨테이너는 동일한 네트워크 네임스페이스와 와  UTS 네임스페이스 안에서 실행되기 때문에, 모든 컨테이너는 같은 호스트 이름과 네트워크 인터페이스를 공유한다.  

* 그러나 대부분의 컨테이너 파일시스템은 컨테이너 이미지에서 나오기 때문에, 기본적인 파일시스템은 다른 컨테이너와 완전히 분리된다.  

* 파드 안의 컨테이너가 동일한 네트워크 네임스페이스에서 실행되기 때문에, 동일한 IP 주소와 포트 공간을 공유한다. 따라서 동일한 파드 안 컨테이너에서 실행 중인 프로세스가 같은 포트 번호를 사용하지 않도록 주의해야 한다.  

* 파드 안에 있는 모든 컨테이너는 동일한 루프백 네트워크 인터페이스를 갖기 때문에, 컨테이너들이 로컬호스트를 통해 서로 통신할 수 있다.  
* 쿠버네티스 클러스터의 모든 파드는 하나의 플랙한 공유 네트워크 주소 공간에 상주하므로 모든 파드는 다른 파드의 IP 주소를 사용해 접근하는 것이 가능하다. 둘 사이에 어떠한 NAT도 존재하지 않고, 두 파드가 서로 네트워크 패킷을 보내면, 상대방의 실제 IP 주소를 패킷 안에 있는 출발지 IP 주소에서 찾을 수 있다.
* **동일한 파드에서 실행한 프로세스는 각 프로세스가 컨테이너 안에 캡슐화돼 있다는 점을 제외하면, 같은 물리적 혹은 가상머신에서 동작하는 것과 동일하다.**

<br/>

### 파드에서 컨테이너의 적절한 구성

파드는 상대적으로 가볍기 때문에 오버헤드 없이 필요한 만큼 파드를 가질 수 있다. 모든 것을 파드 하나에 넣는 대신에 애플리케이션을 여러 파드로 구성하고, 각 파드에는 밀접하게 관련 있는 구성 요소나 프로세스만 포함해야 한다.

* 다계층 애플리케이션을 여러 파드로 분할
  * fe와 be가 같은 파드에 있따면, 항상 같은 노드에서 실행이 된다. 2개의 노드가 있고 파드가 하나가 있다면 워커 노드를 1개만 사용하게되고 나머지 1개는 활용되지 않고 버리게 될 것이다. 파드를 2개로 분리하면 쿠버네티스가 각각 다른 노드로 스케줄링해 인프라스트럭처의 활용도를 향상시킬 수 있다.
* 개별 확장이 가능하도록 여러 파드로 분할
  * fe와 be 컨테이너를 한 파드에 두면 확장 시에 fe 컨테이너 2개와 be 컨테이너 2개를 갖게된다. fe와 be의 스케일링 요구 사항이 다르기 때문에 개별적으로 스케일링이 필요한 경우가 있기 때문에 별도 파드에 배포해야 한다.
* 파드에서 여러 컨테이너를 사용하는 경우
  * 여러 컨테이너를 단일 파드에 넣는 경우도 있다. 로그 수집이나 통신 어댑터 등 지원 컨테이너의 경우가 대표적인 예이다. 
* 파드에서 여러 컨테이너를 사용하는 경우 결정
  * 컨테이너를 함께 실행해야 하는가, 혹은 서로 다른 호스트에서 실행할 수 있는가?
  * 여러 컨테이너가 모여 하나의 구성 요소를 나타내는가, 혹은 개별적인 구성 요소인가?
  * 컨테이너가 함께, 혹은 개별적으로 스케일링돼야 하는가?

<br/>

## YAML 또는 JSON 디스크립터로 파드 생성

앞서 사용했던 ``kubectl run`` 명령어 말고 JSON이나 YAML를 통해 생서이 가능하다.  

기존에 생성한 파드의 정보를 ``kubectl get pod [pod name] -o yaml`` 를 통해 살펴보면 크게 아래와같이 나눌 수가 있다. 

* 사용한 쿠버네티스 API 버전
* 쿠버네티스 오브젝트 유형
* 파드 메타데이터 (Metadata)
  * 이름, 네임스페이스, 레이블 및 파드에 관한 기타 정보를 포함한다.
* 파드 정의/내용 (Spec)
  * 파드 컨테이너 목록, 볼륨, 기타 데이터 등 파드 자체에 관해 실제 명세를 가진다.
* 파드와 그 안의 여러 컨테이너의 상세한 상태 (Status)
  * 파드 상태, 각 컨테이너 설명과 상태, 파드 내부 IP, 기타 기본 정보 등 현재 실행 중인 파드에 관한 현재 정보를 포함한다.

<br/>

### 파드 정의 yaml 작성하기

```yaml
apiVersion: v1
kind: Pod   // 오브젝트 종류는 파드
metadata:
  name: kubia-manual  // 파드 이름
spec:
  containers:
  - image: bepoz/kubia
    name: kubia   // 컨테이너 이름
    ports:
    - containerPort: 8080  // 애플리케이션이 수신하는 포트
      protocol: TCP
```

컨테이너의 포트를 지정해둔 것은 단지 정보일 뿐이다. 생략되어도 다른 클라이언트가 포트를 통해 파드에 연결할 수 있는 여부에 영향을 미치지 않는다. 그러나 명시적으로 포트를 정의한다면, 클러스터를 사용하는 모든 사람이 파드에서 노출한 포트를 빠르게 볼 수 있다. 또한 포트를 명시적으로 정의하면 포트에 이름을 지정해 편리하게 사용할 수 있다.  

위의 yml 파일을 이용해 생성을 하려면 ``kubectl create -f [yml name]`` 을 하면된다.  
``kubectl get pods [pod name] -o yaml`` 을 통해 정의를 가져올 수 있다. yaml 대신 json 으로 입력하면 json 형식으로 출력이 된다.  

<Br/>

### 애플리케이션 로그 보기

컨테이너화된 애플리케이션은 로그를 파일에 쓰기보다는 표준 출력과 표준 에러에 로그를 남기는 게 일반적이다. 이를 통해 사용자는 다른 애플리케이션 로그를 간단하고 동일한 방식으로 볼 수 있다.  

컨테이너 런타임(여기서는 도커)은 이러한 스트림을 파일로 전달하고, ``kubectl logs [pod name]`` 을 이용해 컨테이너 로그를 가져올 수가 있다.  

컨테이너 이름을 지정해 로그를 가져올 수도 있다. ``kubectl logs [pod name] -c [container name]`` 

현재 존재하는 파드의 컨테이너 로그만 가져올 수 있다는 점에 유의해야 한다. 파드가 삭제되면 해당 로그도 같이 삭제된다.  

파드가 삭제된 후에도 파드의 로그를 보기 위해서는 모든 로그를 중앙 저장소에 저장하는 클러스터 전체의 중앙집중식 로깅을 설정해야 한다.  

<Br/>

### 파드에 요청 보내기

서비스를 거치지 않고 특정 파드와 대화하고 싶을 때 쿠버네티스는 해당 파드로 향하는 포트 포워딩을 구성해준다.  

``kubectl port-forward kubia-manual 8888:8080`` 이 명렁어다.  

이 명령은 머신의 로컬 포트 8888을 kubia-manual 파드의 8080포트로 향하게 한다.

<br/>

## 레이블을 이용한 파드 구성

파드가 많아짐에 따라 각 파드에 대해 개별적으로 작업을 수행하기보다 특정 그룹에 속한 모든 파드에 관해 한 번에 작업하기를 원할 것이다. 레이블을 통해 파드와 기타 다른 쿠버네티스 오브젝트의 조직화가 이뤄진다.  

<br/>

### 레이블  소개

레이블은 리소스에 첨부하는 키-값 쌍으로, 이 쌍은 레이블 셀렉터를 사용해 리소스를 선택할 때 활용된다.

<img width="820" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/06c58826-08ea-4040-b856-2cbd463b588c">

위와 같이 레이블을 이용해 시스템 구조와 각 파드가 적합한 위치에 있는지 볼 수 있다.  

<br/>

### 파드를 생성할 때 레이블 지정

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-manual-v2
  labels:
    creation_method: manual
    env: prod
spec:
  containers:
  - image: bepoz/kubia
    name: kubia
    ports:
    - containerPort: 8080
      protocol: TCP
```

위와 같이 labels 를 추가하고 ``k get pods --show-labels`` 명령어를 호출하면 레이블과 함께 파드의 정보가 출력된다.  

![image](https://github.com/Be-poz/TIL/assets/45073750/4bd5fca7-1d0a-4417-934f-e3e8be4a513e)

``k get pods -L creation-method,env``를 입력하면 특정 레이블의 값만 출력하게끔 할 수도 있다.  

![image](https://github.com/Be-poz/TIL/assets/45073750/522bfb08-e924-49bb-b259-e7e2e832b241)

레이블 추가를 위해서는 ``kubectl label po kubia-manual creation_method=manual`` 와 같이 사용한다.  
기존의 레이블을 변경하기 위해서는 위의 명령어 형식에 뒤에 ``--overwrite``를 사용하면 된다.  

<br/>

## 레이블 셀렉터를 이용한 파드 부분 집합 나열

### 레이블 셀렉터를 사용해 파드 나열

* 특정 레이블이 달린 파드 조회
  * ``k get po -l [label key]=[label value]`` 
* 특정 레이블을 가지고 있지만 값은 무엇이든 상관 없는 파드 조회
  * ``k get po -l [label key]``
* 특정 레이블을 가지고 있지 않은 파드 조회
  * ``k get po -l '![lable key]'`` 
* 특정 레이블의 값이 아닌 파드 조회
  * ``k get po -l '[label key]!=[label value]'`` 
* 특정 레이블의 값이 주어진 값 들에 속하는 파드 조회
  * ``k get po -l '[label key] in  (label value들을 ','로 구분해서 쓰면 됨)'``
* 특정 레이블의 값이  주어진 값 들에 속하지 않는 파드 조회
  * ``k get po -l '[lable key] notin (label value들)'``

* 여러 레이블 기준을 둘 수도 있다.
  * ``k get po -l [label key]=[label name],[label key]=[label name]``

<br/>

## 레이블과 셀렉터를 이용해 파드 스케줄링 제한

생성된 파드는 워커 노드 전체에 무작위로 스케줄링 된다. 하지만 만약 어떤 워커 노드는 HDD이고 어떤 노드는 SDD 인 경우 특 정 파드를 한 그룹에 나머지 파드는 다른 그룹에 스케줄링되도록 할 수 있다. GPU 가속을 제공하는 노드에만 GPU 계산이 필요한 파드를 스케줄링하는 것도 좋은 예시일 것이다.  

쿠버네티스의 전체적인 아이디어는 그 위에 실행되는 애플리케이션으로부터 실제 인프라스트럭처를 숨기는 것에 있기에 파드가 어떤 노드에 스케줄링돼야 하는지 구체적으로 지정하고 싶지는 않을 것이다. 그로 인해 애플리케이션이 인프라스트럭처에 결합되기 때문이다. 그러나 정확한 노드를 지정하는 대신 필요한 노드 요구 사항을 기술하고 쿠버네티스가 요구 사항을 만족하는 노드를 선택하도록 한다. 이는 노드 레이블과 레이블 셀렉터를 통해 할 수 있다.  

<br/>

### 워커 노드 분류에 레이블 사용

``k label nodes [node name] [label key]=[label value]`` 로 노드에도 레이블을 부여할 수가 있다.  

<br/>

### 특정 노드에 파드 스케줄링

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-conqueror
spec:
  nodeSelector:
    conqueror: bepoz
  containers:
  - image: bepoz/kubia
    name: kubia
```

``nodeSelector`` 속성을 줘서 ``conqueror: bepoz`` 레이블이 붙은 노드에 스케줄링 되게끔 했다.  

<br/>

## 파드에 어노테이션 달기

어노테이션은 키-값 쌍으로 레이블과 거의 비슷하지만 식별 정보를 갖지 않는다. 오브젝트를 묶을 수도 없고 어노테이션 셀렉터도 없다. 주로 도구들(tools)에서 사용된다. 쿠버네티스에서 새로운 기능을 추가할 때 흔히 사용된다. 일반적으로 새로운 기능의 알파 혹은 베타 버전은 API 오브젝트에 새로운 필드를 바로 도입하지 않는다. 필드 대신 어노테이션을 사용하고, 필요한 API 변경이 명확해지고 쿠버네티스 개발자가 이에 동의하면 새로운 필드가 도입된다.  

어노테이션이 유용하게 사용되는 경우는 파드나 다른 API 오브젝트에 설명을 추가해 두는 것이다. 이렇게 하면 클러스터를 사용하는 모든 사람이 개별 오브젝트에 관한 정보를 신속하게 찾아볼 수 있다. 예를 들어 오브젝트를 만든 사람 이름을 어노테이션으로 지정해두면, 클러스터에서 작업하는 사람들이 좀 더 쉽게 협업할 수 있다.

<br/>

### 오브젝트의 어노테이션 조회

``k get po [pod name] -o yaml`` 로 yaml 파일을 확인해보자.  
``k describe pod [pod name]`` 으로도 확인가능하다.  

![image](https://github.com/Be-poz/TIL/assets/45073750/5e6994c0-5635-4cb4-802e-12a982647a5f)

어노테이션 정보가 있는 것을 확인할 수가 있을 것이다.  
레이블에는 짧은 데이터를, 그에 비해 어노테이션에는 상대적으로 큰 데이터를 넣을 수 있다 (총 256KB까지).  

<br/>

### 어노테이션 추가 및 수정

``k annotate pod [pod name] [annotation key]=[annotation value]``

변경을 원할 때에는 레이블 때와 마찬가지로 ``--overwrite``을 뒤에 붙여주면 된다.  
<br/>

## 네임스페이스를 사용한 리소스 그룹화

각 오브젝트는 여러 레이블을 가질 수 있기 때문에 오브젝트 그룹은 서로 겹쳐질 수 있다.  
또한 클러스터에서 작업을 수행할 때 레이블 셀렉터를 명시적으로 지정하지 않으면 항상 모든 오브젝트를 보게 된다.  

오브젝트를 겹치지 않는 그룹으로 분할하고자 할 때, 즉 한 번에 하나의 그룹 안에서만 작업하고 싶을 때에 네임스페이스로 그룹화한다. 

<br/>

### 네임스페이스의 필요성

여러 네임스페이스를 사용하면 많은 구성 요소를 가진 복잡한 시스템을 좀 더 작은 개별그룹으로 분리할 수 있다.  
리소스 이름은 네임스페이스 안에서만 고유하면 된다. 서로 다른 두 네임스페이스는 동일한 이름의 리소스를 가질 수 있다.  

대부분의 리소스 유형은 네임스페이스 안에 속하지만 일부는 그렇지 않다. 그 가운데 하나는 노드 리소스인데, 이 리소스는 전역이며 단일 네임스페이스에 얽매이지 않는다.  

<Br/>

### 다른 네임스페이스와 파드 살펴보기

``k get ns`` 를 하면 네임스페이스의 목록이 나열된다.  

``k get [object] -n [namespace]`` 를 입력하면 해당 네임스페이스에 속해있는 오브젝트를 확인할 수 있다.  

<br/>

### 네임스페이스 생성

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: custom-bepoz
```

이렇게 yml파일로 생성도 가능하지만 ``k create namespace [namespace 명]`` 으로도 생성이 가능하다.  

<br/>

### 다른 네임스페이스의 오브젝트 관리

metadata 섹션에 ``namespace: custom-bepoz`` 와 같은 항목을 넣거나,  
 ``k create -f [yaml 파일] -n [namespace]``와 같이 네임스페이스를 지정해주는 방법을 사용하면 된다.  

또는 ``k config set-context --current --namespace=[namespace 명]`` 명령어로 현재 컨텍스트를 default에서 본인이 원하는 namespace로 변경할 수 있다.  

<br/>

### 네임스페이스가 제공하는 격리 이해

네임스페이스를 사용하면 오브젝트를 별도 그룳으로 분리해 특정한 네임스페이스 안에 속한 리소스를 대상으로 작업할 수 있게 해주지만, 실행 중인 오브젝트에 대한 격리는 제공하지 않는다.  

다른 네임스페이스를 가진 파드가 배포되어 있다고해서 네트워크 격리가 된 것은 아니다. 이것은 쿠버네티스와 함께 배포하는 네트워킹 솔루션에 따라 다르다. 격리가 제공되지 않는다면 foo 네임스페이스를 가진 파드에서 bar 네임스페이스를 가진 파드의 IP 주소로 HTTP 요청과 같은 트래픽을 다른 파드로 보내는 것에 아무런 제약 사항이 없다.  

<Br/>

## 파드 중지와 제거

``k delete po [pod name]`` 으로 파드를 삭제한다.  

파드를 삭제하면 쿠버네티스는 파드 안에 있는 모든 컨테이너를 종료하도록 지시한다.  
쿠버네티스는 SIGTERM 신호를 프로세스에 보내고 지정된 시간(기본 30초) 동안 기다린다. 시간 내에 종료되지 않으면 SIGKILL 신호를 통해 종료한다. 프로세스가 항상 정상적으로 종료되게 하기 위해서는 SIGTERM 신호를 올바르게 처리해야 한다.  

``k delete po [pod name1] [pod name2]`` 이렇게 파드 이름 중간에 공백을 두어 여러 파드를 삭제할 수도 있다.  

``k delete po -l [label name]=[label value]`` 와 같이 레이블 셀렉터를 이용해 삭제할 수 있다.  

``k delete ns [namespace]`` 로 네임스페이스 전체를(파드는 네임스페이스와 함께 자동으로 삭제된다) 삭제할 수 있다.  

``k delete po --all`` 명령어로 파드를 모두 삭제할 수 있다. 레플리카셋이 관리하고 있는 파드들이면 바로 재생성될 것이다.  

``k delete all --all`` 이 명령어로 현재 네임스페이스에 있는 모든 리소스를 삭제할 수 있다.  

---

