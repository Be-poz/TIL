# 코루틴과 Async/Await

코루틴은 비선점형 멀티태스킹을 수행하는 일반화한 서브루틴이다.  
코루틴은 실행을 일시 중단(suspend)하고 재개(resume) 할 수 있는 여러 진입 지점(entry point)을 허용한다.  

코루틴이란 서로 협력해서 실행을 주고받으면서 작동하는 여러 서브루틴을 말한다.  
함수 A가 실행되다가 코루틴 B를 호출하면 A가 실행되던 스레드 안에서 코루틴 B의 실행이 시작된다. 코루틴 B는 실행을 진행하다가 실행을 A에 양보한다(yield라는 명령을 사용하는 경우가 많다). A는 다시 코루틴을 호출했던 바로 다음 부분부터 실행을 계속 진행하다가 또 코루틴 B를 호출한다. B가 일반적인 함수라면 로컬 변수를 초기화하면서 처음부터 실행을 다시 시작하겠지만, 코루틴이면 이전에 yield로 실행을 양보했던 지점부터 실행을 계속하게 된다.  

<img width="467" alt="image" src="https://github.com/Be-poz/TIL/assets/45073750/74e86195-65c4-4be1-add6-f8f23d874295">

```kotlin
fun main(args: Array<String>) {
    log("main started")
    launchInGlobalScope()
    log("launchInGlobalScope() executed")
    Thread.sleep(2000)
    log("main() terminated")
}

fun now() = LocalDateTime.now().truncatedTo(ChronoUnit.MILLIS)

fun log(msg: String) = println("${now()} [${Thread.currentThread().name}] $msg")

fun launchInGlobalScope() {
    GlobalScope.launch {
        log("coroutine started")
    }
}

/*
2024-01-26T00:42:16.441 [main] main started
2024-01-26T00:42:16.488 [main] launchInGlobalScope() executed
2024-01-26T00:42:16.490 [DefaultDispatcher-worker-1] coroutine started
2024-01-26T00:42:18.490 [main] main() terminated
```

GlobalScope.launch가 만들어낸 코루틴이 서로 다른 스레드에서 실행되는 것을 확인할 수가 있다.  

GlobalScope는 메인 스레드가 실행 중인 동안만 코루틴의 동작을 보장해준다.  
sleep이 없다면 코루틴은 실행되지 않을 것이다. launchInGlobalScope가 호출한 launch는 스레드가 생성되고 시작되기 전에 메인 스레드의 제어를 main()에 돌려주기 때문에 따로 sleep을 하지 않으면 main()이 바로 끝나고 메인 스레드가 종료되면서 프로그램이 끝나기 때문이다.  

이를 방지하려면 비동기적으로 launch를 실행하거나, launch가 모두 다 실행될 때 까지 기다려야 한다.  
특히 코루틴의 실행이 끝날 때까지 현재 스레드를 블록시키는 함수로 runBlocking()이 있다.  
runBlocking은 CoroutineScope의 확장 함수가 아닌 일반 함수이기 때문에 별도의 코루틴 스코프 객체 없이 사용 가능하다.

```kotlin
fun runBlockingExample() {
    runBlocking {
        launch {
            log("GlobalScope.launch started")
        }
    }
}

/*
2024-01-26T00:59:45.726 [main] main started
2024-01-26T00:59:45.768 [main] GlobalScope.launch started
2024-01-26T00:59:45.768 [main] launchInGlobalScope() executed
2024-01-26T00:59:45.769 [main] main() terminated
```

launchInGlobalScope을 위의 함수로 변경하고 돌려보면 스레드가 같다는 것을 확인할 수가 있다.  

```kotlin
fun yieldExample() {
    runBlocking {
        launch {
            log("1")
            yield()
            log("3")
            yield()
            log("5")
        }
        log("after first launch")
        launch {
            log("2")
            delay(1000L)
            log("4")
            delay(1000L)
            log("6")
        }
        log("after second launch")
    }
}
/*
2024-01-26T01:04:11.193 [main] after first launch
2024-01-26T01:04:11.197 [main] after second launch
2024-01-26T01:04:11.198 [main] 1
2024-01-26T01:04:11.200 [main] 2
2024-01-26T01:04:11.205 [main] 3
2024-01-26T01:04:11.205 [main] 5
2024-01-26T01:04:12.203 [main] 4
2024-01-26T01:04:13.206 [main] 6
```

위의 함수를 돌려본 결과이고 이를 토대로 아래를 알 수 있다.  

* launch는 즉시 반환
* runBlocking은 내부 코루틴이 모두 끝난 다음에 반환
* delay()를 사용한 코루틴은 그 시간이 지날 때까지 다른 코루틴에게 실행을 양보한다. 코드에서 delay가 yield였다면 1,2,3,4,5,6 순서대로 출력이 되었을 것이다.

