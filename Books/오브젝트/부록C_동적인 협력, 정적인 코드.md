# 동적인 협력, 정적인 코드
객체는 동적이고 프로그램은 정적이다. 객체는 시간에 따라 다른 객체와 협력하며 계속 변화한다.  
프로그램은 고정된 텍스트라는 형식 안에 갇혀 있으면서도 객체의 모든 변화 가능성을 담아야한다.  

프로그래머는 객체지향 프로그램을 작성하기 위해서는 두 가지 모델을 마음속에 그려야 한다.  
하나는 프로그램을 실행 구조를 표현하는 움직이는 모델인 **동적 모델** 이고,  
다른 하나는 코드의 구조를 담는 고정된 모델인 **정적 모델**이다.  

객체지향에서 동적 모델은 **객체**와 **협력** 이고,  
정적 모델은 **타입**과 **관계** 이다.  

정적 모델은 동적 모델에 의해 주도돼야 한다. 동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 하는 중요한 요소는 **변경**이다.  
설계가 필요한 이유는 변경을 수용할 수 있는 코드를 만들기 위해서이고, 변경을 수용할 수 있는 코드란 다음과 같다.

1. 단순
2. 낮은 결합도
3. 중복이 없는 코드

***
## 동적 모델과 정적 모델
Bird <- Penguin 은 행동을 고려하지 않은 정적 모델이다. 
Bird <- FlyingBird, Penguin은 행동을 고려한 정적 모델이다.  

이 예제는 행동이 코드 구조에 미치는 영향을 보여준다. 행동을 고려하지 않을 경우 개방-폐쇄 원칙을 위반하는 코드가 양산될 수 밖에 없다.  

![capture2](https://user-images.githubusercontent.com/45073750/95651967-bba9d900-0b28-11eb-9d0a-3675fc0710a5.PNG)
위의 모델은 상속 계층에 속한 객체들이 협력 안에서 다양한 정책에 따라 요금을 계산하는 책임을 수행해야 한다는 객체의 행동을 잘 표현한다.  
그러나 변경이라는 측면에서는 좋은 설계가 아니다. 다양한 정책을 조합할수록 중복 코드가 기하급수적으로 증가하게 된다.  
요금 정책 변경을 위해서 인스턴스들 사이에 상태를 복사해야하므로 유연하지도 않다.  
 ![capture3](https://user-images.githubusercontent.com/45073750/95651968-bc426f80-0b28-11eb-9792-d11558c9bf3d.PNG)
 위의 경우에는 변경을 적절히 고려한 정적 모델이라고 할 수가 있다.  

 객체지향 설계관련 서적에서 도메인 모델을 먼저 만들고 모델을 기반으로 설계와 구현을 진행하라고 하는데, 도메인 모델은 정적 모델이지 않나?  
 그리고 이 개념들로 객체 사이의 협력을 설계하니깐 정적 모델이 동적 모델에 기반하는거 아닌가? 라고 생각할 수도 있을 수 있다.  
***
 ## 도메인 모델과 구현
 **도메인**은 사용자가 프로그램을 사용하는 대상 영역을 가리킨다.  
 **모델**은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.  
 **도메인 모델**은 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.  

 도메인 모델을 작성하는 것은 목표가 아니라 출발점이다. 도메인 모델은 소프트웨어를 만드는 데 필요한 개념의 이름과 의미, 그리고 관계에 대한 힌트를 제공하는 역할로 끝나야 한다.  
 도메인 모델이 클래스 다이어그램과 같은 정적인 형태로 표현돼야 한다는 것은 오해다. 도메인 모델은 우리의 도메인에 대한 지식을 표현하고 코드의 구조에 대한
 힌트를 제공할 수 있따면 어떤 형태로 표현하더라도 상관이 없다. 객체 사이의 협력을 도드라지게 보여주는 개념적인 표현 역시 도메인 모델이 될 수 있다.  

 ```java
 public abstract class Monster{
     private int health;
     
     public Monster(int health){
         this.health = health;
     }
     abstract public String getAttack();
 }
 
 public class Dragon extends Monster{
     public Dragon(){
         super(230);
     }
     @Override
     public String getAttack(){
         return "용이 불을 내뿜는다";
     }
 }
 ```
다음의 예제를 보면 몬스터를 추가할 때 Monster 추상클래스를 상속받아 만들게 된다. 개방-폐쇄 원칙을 준수하는 좋은 설계이다.  
그러나, 몬스터를 추가할 때마다 getAttack을 오버라이딩하는 것은 지루한 작업이고 이게 수백 수천이 되면 반복 작업이 되버린다.  

```java
public class Breed{
    private String name;
    private int health;
    private String attack;

    public Breed(String name, int health, String attack) {
        this.name = name;
        this.health = health;
        this.attack = attack;
    }
    
    public int getHealth(){
        return health;
    }
    public String getAttack() {
        return attack;
    }
}

public abstract class Monster{
    private int health;
    private Breed breed;

    public Monster(Breed breed){
        this.health = breed.getHealth();
    }
    public String getAttack(){
        return breed.getAttack();
    }
}

Monster dragon = new Monster(new Breed("용", 230, "용은 불을 내뿜는다"));
```
다음과 같이 2개으 ㅣ클래스만으로 해당 문제를 수정해주었다. 몬스터가 수행해야 하는 행동은 Monster 클래스에, 몬스터의 타입은 Breed클래스에.  
합성을 이용한 다음의 방법은 앞 장에서 핸드폰 요금 시스템의 경우와는 다르게 새로운 클래스를 추가해주지 않기 위해 사용되었다.  
이처럼 어떤 인스턴스가 다른 인스턴스의 타입을 표현하는 방법을 **TYPE OBJECT**패턴 이라고 부른다.  
예제에서 Breed의 인스턴스가 바로 Monster의 타입을 구현하는 **TYPE OBJECT**에 해당한다.  

***
우리는 도메인 모델을 먼저 만들고 만들어진 도메인 모델에 표현된 개념과 관계를 기반으로 협력에 필요한 객체의 후보를 도출하고 구현 클래스의 이름과 관계를 설계한다.
하지만 도메인 모델을 그대로 카피해서는 안된다. 구현하거나 변경하기 더 쉬운 모델이 떠올랐다면 과감하게 초기 아이디어를 버려야 한다.  

도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이 도메인 모델이다.    
작성된 개념이 우리의 코드에 대한 구조와 행동을 드러낸다면 훌륭한 도메인 모델이다. 형식은 중요치 않고 전달하려는 의미가 중요하다.  

말하고자 하는 것은 도메인 모델이 단순히 정적 모델의 형태를 띨 필요가 없으며 도메인 모델의 구조가 코드와 다를 필요가 없다는 것이다.  
도메인 모델은 도메인 안에 존재하는 개념과 관계를 표현해야 하지만 최종 모습은 객체의 행동과 변경에 기반해야 하며 코드의 구조를 반영해야 한다.  
중요한 것은 도메인 모델을 봤을 때 도메인의 개념뿐만 아니라 코드도 함께 이해될 수 있는 구조를 찾는 것이다.  

***