# AOP에 대해 (6)

애플리케이션 로직은 크게 핵심 기능과 부가 기능으로 나눌 수 있다.  
앞서 적용했던 ``LogTrace``가 부가 기능이고 다른 비즈니스 코드들이 바로 핵심 기능이라고 볼 수 있다.  

앞에서 겪어봤듯이, 이런 부가 기능을 여러 곳에 적용하기에는 너무 번거롭기 때문에 부가 기능을 핵심 기능에서 분리하고 한 곳에서 관리하도록 했다. 그리고 부가 기능을 어디에 적용할지 선택하는 기능을 만들었다. 부가 기능과 어디에 적용할지 선택하는 기능을 합해서 하나의 모듈로 만들었고 이것이 바로 Aspect다. 앞서 ``@Aspect``로 사용을 해보았다. 스프링이 제공하는 Advisor 도 Advice(부가 기능)과 Pointcut(적용 대상)을 가지고 있어서 개념상 하나의 Aspect다.  

Aspect를 사용한 프로그래밍을 관점 지향 프로그래밍, AOP(Aspect-Oriented Programming)이라 한다.  
AOP는 OOP를 대체하기 위한 것이 아니라 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 부족한 부분을 보조하는 목적으로 개발되었다.  

<br/>

AOP의 대표적인 구현으로 AspectJ 프레임워크가 있다.  
스프링도 AOP를 지원하지만 대부분 AspectJ의 문법을 차용하고, AspectJ가 제공하는 기능의 일부만 제공한다.  

AOP 적용 방식에는 크게 3가지가 있다.  

* 컴파일 시점
* 클래스 로딩 시점
* 런타임 시점(프록시)

<br/>

### 컴파일 시점

![image](https://user-images.githubusercontent.com/45073750/148240077-89d8c8b3-1053-4383-acbe-82d9292feed9.png)

컴파일 시점은 ``.java`` 파일을 ``.class`` 파일로 변환하는 과정에서 AspectJ 컴파일러가 부가 기능 로직을 붙이는 방식이다.  
컴파일된 ``.class``를 디컴파일 해보면 Aspect 관련 호출 코드가 들어간다.  
위빙이란, 원본 로직에 부가 기능 로직이 추가되는 것을 말한다.  

컴파일 시점의 단점은 특별한 컴파일러가 필요하고 복잡하다는 것이다.  

<Br/>

### 클래스 로딩 시점

![image](https://user-images.githubusercontent.com/45073750/148240382-08ebe856-b389-49db-b9bd-e6f1ec0b736b.png)

클래스 로딩 시점은 ``.class`` 파일을 JVM에 저장하기 전에 코드 조작을 하는 것이다. 많은 모니터링 툴들이 사용하는 방식이다.  
이 시점에 Aspect를 적용하는 것을 로드 타임 위빙이라 한다.  

클래스 로딩 시점의 단점은 로드 타임 위빙이 자바 실행 시 특별한 옵션(java -javaagent)을 통해 클래스 로더 조작기를 지정해야 하는데, 이 부분이 번거롭고 운영하기 어렵다는 점이다.  

<Br/>

### 런타임 시점

![image](https://user-images.githubusercontent.com/45073750/148240763-c9b1b045-86a0-4ed0-a743-885dce274372.png)

앞서 코드로 적용했던 것이 바로 런타임 시점 방식이었다. 프록시 방식의 AOP이다.  
프록시를 사용하기 때문에 AOP 기능에 일부 제약이 있다.(프록시에서 target의 메서드를 호출하기 때문에 생성자 등의 조작이 불가능함(반면 위의 2가지 경우는 가능함). 컴파일 시점 처럼 특별한 컴파일러나 클래스 로딩 시점처럼 클래스 로더 조작기를 설정하지 않아도 된다.  

3가지 방식을 정리하자면, 컴파일 시점과 클래스 로딩 시점은 실제 대상 코드에 Aspect를 통한 부가 기능 호출 코드가 포함된다는 것이다. AspectJ를 직접 사용해야 한다. 런타임 시점은 실제 대상 코드는 그대로 유지되고 프록시를 통해 부가 기능이 적용된다는 것이다. 스프링 AOP가 사용하는 방식이다.  

AOP를 적용할 수 있는 지점을 조인 포인트(Join point)라 한다(이전에 다뤘던 코드에서 ``request()``, ``save()`` 가 바로 조인 포인트다).  

런타임 시점 방식에서 언급했지만, 프록시 방식을 사용하는 스프링 AOP는 메서드 실행 지점에만 AOP를 적용할 수 있다.  
프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없다.  
프록시를 사용하는 스프링 AOP의 조인 포인트는 메서드 실행으로 제한된다.  
프록시 방식을 사용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP를 적용할 수 있다.  

스프링은 AspectJ를 직접 사용하는 것이 아니라 AspectJ의 문법을 차용하고 프록시 방식의 AOP를 적용한다.  

<br/>

