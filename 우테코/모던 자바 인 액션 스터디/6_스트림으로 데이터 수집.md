# 6. 스트림으로 데이터 수집

컬렉터로 스트림의 항목을 컬렉션으로 재구성할 수 있다.  

``long howManyDishes = menu.stream().collect(Collectors.counting())`` 다음과 같이 말이다.  
물론 이 코드는 ``menu.stream().count()``로 생략할 수 있다.  

```java
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish:;getCalories);

Optional<Dish> mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));
```

``maxBy``, ``minBy``를 이용해서 스트림의 최댓값과 최솟값을 계산할 수 있다.  
``summingInt``는 객체를 int로 매핑하는 함수를 인수로 받고 그 값들을 더한다.  
``int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));``  

``summingDouble``도 있으며, 합계 뿐만 아니라 평균값 등도 ``averagingInt``, ``averagingLong``, ``averagingDouble`` 등을 이용해 구할 수 있다.  

``joining``을 이용해 문자열을 연결할 수도 있다.  

```java
        List<String> list = List.of("a", "b", "c");
        String collect = list.stream().map(String::valueOf)
                .collect(Collectors.joining(", "));//delimiter를 넣을 수도 있음
// a, b, c
```

컬렉터는 reducing 팩토리 메서드로도 정의할 수 있다.  

``int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -> i + j));``  

해당 메서드는 ``map(Dish::getCalories).reduce(0, (i, j) -> i + j);`` 로도 요약가능하다.  

> collect 메서드는 도출하려는 결과를 누적하는 컨테이너를 바꾸도록 설계된 메서드인 반면 reduce는 두 값을 하나로 도출하는 불변형 연산이라는 점에서 의미론적인 문제가 일어난다. 여러 스레드가 동시에 같은 데이터 구조체를 고치면 리스트 자체가 망가져버리므로 리듀싱 연산을 병렬로 수행할 수 없다는 점도 문제다. 가변 컨테이너 관련 작업이면서 병렬성을 확보하려면 collect 메서드로 리듀싱 연산을 구현하는 것이 바람직하다.

팩토리 메서드 ``Collectors.groupingBy``를 이용하면 쉽게 그룹화할 수 있다.  

``Map<Dish.Type, List<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType));``  
{Fish = [params, salmon], OTHER = [french fries, rice, season fruit, pizza]}  
분류를 하는 함수를 **분류 함수**라고 부른다. 분류 함수가 곧 키가 되고, 값은 해당 조율에 포함되는 요소들이다.  

```java
Map<Dish.Type, List<Dish>> caloricDishesByType =
    						menu.stream().filter(dish -> dish.getCalories() > 500)
	    						.collect(groupingBy(Dish::getType));
// {OTHER = [french fries, pizza], MEAT = [pork, beef]}

Map<Dish.Type, List<Dish>> caloricDishesByType =
    						menu.stream()
    							.collect(groupingBy(Dish::getType,
                                                   	filtering(dish -> dish.getCalories() > 500, toList())));
// {FISH = [], OTHER = [french fries, pizza], MEAT = [pork, beef]}
```

``.filter()``로 먼저 거르고 컬렉터를 사용하면 위의 예제와 같이 요소가 없는 Type은 아예 출력이 되질 않는다.  
이럴 때에는 ``groupingBy()`` 내부에 필터링 컬렉터를 따로 주면된다.  

```java
Map<Dish.Type, List<String>> dishNamesByType =
    							menu.stream()
    								.collect(groupingBy(Dish::getType, mapping(Dish::getName, toList())));
```

다음과 같이 밸류를 다른 형태로 매핑할 때에는 ``mapping``을 사용한다.  

```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel =
    	menu.stream().collect(
			groupingBy(Dish::getType),
				groupingBy(dish -> {
                    if(dish.getCalories() <= 400) return CaloricLevel.DIET;
                    if(dish.getCalories() <= 800) return CaloricLevel.NORMAL;
                    return CaloricLevel.FAT;
                }))
    );
/*
{MEAT = {DIET = [chicken], NORMAL = [beef], FAT =[pork]},
 FISH = {DIET = [prawns] ....}}
```

다수준 그룹화도 가능하다.  

```java
Map<Dish.Type, Long> typesCount = menu.stream().collect(
									groupingBy(Dish::getType, counting()));
Map<Dish.Type, Optional<Dish>> mostCaloricByType = menu.stream()
    .collect(groupingBy(Dish::getType, maxBy(comparingInt(Dish::getCalories))));
```

두 번째 인수에 원하는 컬렉터를 던져서 수행할 수도 있다.  

```java
Map<Dish.Type, Dish> mostCaloricByType = menu.stream()
    .collect(groupingBy(Dish::getType,
              collectingAndThen(
                  maxBy(comparingInt(Dish::getCalories)),
              Optional::get)));
```

컬렉터 결과를 다른 형식에 적용할 수도 있다.  

* 컬렉터는 점선으로 표시되어 있으며 groupingBy는 가장 바깥쪽에 위치하면서 요리의 종류에 따라 메뉴 스트림을 세 개의 서브스트림으로 그룹화한다. 
* groupingBy 컬렉터는 collectingAndThen 컬렉터를 감싼다. 따라서 두 번째 컬렉터는 그룹화된 세 개의 서브스트림에 적용된다.
* collectingAndThen 컬렉터는 세 번째 컬렉터 maxBy를 감싼다.
* 리듀싱 컬렉터가 서브스트림에 연산을 수행한 결과에 collectingAndThen의 Optional::get 변환 함수가 적용된다.
* groupingBy 컬렉터가 반환하는 맵의 분류 키에 대응하는 세 값이 각각의 요리 형식에서 가장 높은 칼로리다.

두 번째 인자로 들어가는 컬렉터가 곧 Map의 value가 된다는 것만 알아두면 이해하기 편하다.  

분할은 **분할 함수**라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다. 분할 함수는 불리언을 반환하므로 맵의 키 형식은 Boolean이다. 결과적으로 그룹화 맵은 최대 두 개의 그룹으로 분류된다.  

```java
Map<Boolean, List<Dish>> partitionedMenu =
    					menu.stream().collect(partitioningBy(Dish::isVegetarian));
```

다음과 같이 말이다.  

분할의 장점은 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이다. 두 번째 인수로 잘게 더 나눌 수도 있다.  

```java
{false = {FISH = [prawns, salmon], MEAT = [pork, beef, chicken]},
 true = {OTHER = [french fries, rice, season fruit, pizza]}}
```

``partitioningBy(Dish:isVegetarian, collectingAndThen(maxBy(comparingInt(Dish::getCalories)), Optional::get));``  
이렇게 응용할 수도 있다.  

***