# 5. 스트림 활용

* filter 메서드는 Predicate를 인수로 받아서 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다.  
* dictinct는 중복을 필터링한다. (고유 여부는 hashCode와 equals로 결정된다)

* takeWhile 를 이용하면 해당 프레디케이트가 false면 동작을 멈춘다.  

  ```java
  List<Dish> filteredMenu = 
      specialMenu.stream()
      .takeWhile(dish -> dish.getCalories() < 320)
      .collect(toList());
  ```

  specialMenu 내부에 칼로리 오름차순으로 정렬이 되어있다면 해당 프레디케이트가 true일 동안만 작동한다. filter 였으면 다 돌았을 것이다.  

* dropWhile은 해당 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버린다.

  ```java
  List<Dish> slicedMenu =
      specialMenu.stream()
      .dropWhile(dish -> dish.getCalories() <320)
      .collect(toList());
  ```

* limit은 주어진 크기 까지만 반환한다.

* skip은 주어진 크기만큼 요소를 제외한다.

* flatMap은 생성된 스트림을 하나의 스트림으로 평면화 시킨다.

  ```java
  List<String> uniqueCharacters = 
      words.stream()
      .map(word -> word.split(""))
      .flatMap(Arrays::stream)
      .distinct()
      .collect(toList());
  ```

  각 단어들을 잘라서 평면화된 스트림으로 만들고 distinct()를 이용해서 사용된 문자들만 List로 받는다.  

* .reduce( 초기값, 리듀싱 연산) 을 통해 복잡한 질의를 표현할 수 있다. 초기값이 없는 경우에는 Optional를 받게된다. 왜냐하면, 스트림에 아무 요소도 없을 수 있기 때문이다.

* map, filter는 입력 스트림에서 각 요소를 받아 0 또는 결과를 출력 스트림으로 보낸다. **내부 상태를 갖지 않는 연산**이다.  
  reduce, sum, max는 결과를 누적할 **내부 상태가 필요**하다. 스트림엣 ㅓ처리하는 요소 수와 관계없이 내부 상태의 크기는 **한정**되어 있다.  
  sorted, distinct는 과거의 이력을 알고 있어야 한다. **모든 요소가 버퍼에 추가되어 있어야 한다.** 이러한 연산을 **내부 상태를 갖는 연산**이라고 한다.

* IntStream은 max, min, average 등의 유틸리티 메서드를 지원한다.

* 기본형 스트림으로 박싱과 언박싱은 .mapToInt, .boxed() 등을 이용할 수 있다.

* 특정 숫자 범위를 이용하기 위해 IntStream.rangeClosed(1,100) 등과 같이 이용할 수 있다. range는 표기값을 포함하지 않는다.

* Stream.iterate(초깃값, 람다) 를 통해 무한스트림을 만들 수 있다. ex. Stream.iterate(0, n -> n + 2)

  프레디케이트도 지원한다. 0에서 시작해서 100보다 크면 숫자 생성을 중단하는 코드는 다음과 같이 구현 가능하다. IntStream.iterate(0, n -> n < 100, n -> n + 4)

* Stream.generate 또한 무한스트림을 만들 수 있다. iterate와 같이 생산된 각 값을 연속적으로 계산하지 않는다. Supplier<T>를 인수로 받아서 새로운 값을 생산한다. 

***

