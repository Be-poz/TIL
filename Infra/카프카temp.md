* 주키퍼: 아파치 프로젝트 애플리케이션 이름, 카프카의 메타데이터 관리 및 브로커의 정상상태 점검을 담당

* 카프카, 카프카 클러스터: 아파치 프로젝트 애플리케이션 이름, 여러 대의 브로커를 구성한 클러스터를 의미
* 브로커: 카프카 애플리케이션이 설치된 서버 또는 노드
* 프로듀서: 카프카로 메세지를 보내는 역할을 하는 클라이언트를 총칭
* 컨슈머: 카프카에서 메세지를 꺼내가는 역할을 하는 클라이언트를 총칭
* 토픽: 카프카는 메세지 피드들을 토픽으로 구분하고, 각 토픽의 이름은 카프카 내에서 고유함
* 파티션: 병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것을 말함
* 세그먼트: 프로듀서가 전송한 실제 메시지가 브로커의 로컬 디스크에 저장되는 파일ㅇ르 말함
* 메시지 또는 레코드: 프로듀서가 브로커로 전송하거나 컨슈머가 읽어가는 데이터 조각을 말함



### 레플리케이션

카프카에서 레플리케이션이란 각 메시지들을 여러 개로 복제해서 카프카 클러스터 내 브로커들에 분산시키는 동작을 의미한다. 이러한 리플리케이션 동작 덕분에 하나의 브로커가 종료되더라도 카프카는 안정성을 유지할 수 있다.  

replication-factor: 카프카 내 몇 개의 리플리케이션을 유지하겠다는 의미  

리플리케이션 팩터 수가 커지면 안정성은 높아지지만 그만큼 브로커 리소스를 많이 사용하게 된다. 따라서 복제에 대한 오버헤드를 줄여서 최대한 브로커를 효율적으로 사용하는 것을 권장한다. 기준을 세워두고 리플리케이션 팩터 수를 설정해야한다.  

* 테스트나 개발 환경: 리플리케이션 팩터 수를 1로 설정
* 운영 환경(로그성 메시지로서 약간의 유실 허용): 레플리케이션 팩터 수를 2로 설정
* 운영 환경(유실 허용하지 않음): 리플리케이션 팩터 수를 3으로 설정



### 파티션

하나의 토픽이 한 번에 처리할 수 있는 한계를 높이기 위해 토픽 하나를 여러 개로 나눠 병렬 처리가 가능하게 만든 것을 파티션이라고 한다. 하나를 여러 개로 나누면 분산 처리도 가능하다. 나뉜 파티션 수만큼 컨슈머를 연결할 수 있다.  

파티션 번호는 0부터 시작한다.  

**파티션 수는 초기 생성 후 언제든지 늘릴 수 있지만, 반대로 한 번 늘린 파티션 수는 절대로 줄일 수 없다는 점을 반드시 명심**  



### 세그먼트

프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장되며, 각 메시지들은 세그먼트라는 로그 파일의 형태로 브로커의 로컬 디스크에 저장된다.  

파티션이 1개인 a라는 토픽을 예로 들어 정리하자면,  

1. 프로듀서는 카프카의 a 토픽으로 메시지를 전송
2. 메시지를 받은 a 토픽은 파티션이 하나뿐이므로, 프로듀서로부터 받은 메시지를 파티션n의 세그먼트 로그 파일에 저장
3. 브로커의 세그먼트 로그 파일에 저장된 메시지는 컨슈머가 읽어갈 수 있음

<br/>

## 카프카의 핵심 개념

### 분산 시스템

분산 시스템으로 인하여 성능이 높고 하나의 서버 또는 노드 등에 장애가 발생해도 다른 서버 또는 노드가 대신 처리하므로 

